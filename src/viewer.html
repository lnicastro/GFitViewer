<!DOCTYPE html>
<html>
<head>
  <title>The GFit viewer</title>
  <meta http-equiv=Content-Type content="text/html; charset=UTF-8" />
  <meta http-equiv=Content-Script-Type content="text/javascript" />
  <meta http-equiv=Content-Style-Type content="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="GFitViewer - web viewer for the GFit produced results" />
  <meta name="generator" content="vi+LN" />
  <meta name="author" content="Luciano Nicastro, INAF" />
  <meta name="publisher" content="INAF" />
  <meta name="language" content="en" />
  <meta name="version" content="0.1" />
  <meta name="date" content="2021-04-01" />

<!-- @Remote
-->
  <link href="https://qsfit.inaf.it/images/qsfit_logo.ico.gif" rel="shortcut icon" type="image/x-icon" />

  <script src="https://www.amcharts.com/lib/4/core.js"></script>
  <script src="https://www.amcharts.com/lib/4/charts.js"></script>
  <script src="https://www.amcharts.com/lib/4/themes/animated.js"></script>
  <link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" type="text/css" rel="stylesheet" crossorigin="anonymous" />


<style>
body {
  font: 90%/1.45em adobe-clean-n3, adobe-clean, "Helvetica Neue", HelveticaNeue, Helvetica, Arial, sans-serif;
  color: #333;
  margin: 5px;
  text-rendering: optimizeLegibility !important;
  -webkit-font-smoothing: antialiased !important;
  -moz-osx-font-smoothing: grayscale !important;
}

:root {
--blue: #1177d1;
--indigo: #6610f2;
--purple: #613d7c;
--pink: #e83e8c;
--red: #d43f3a;
--orange: #f0ad4e;
--yellow: #ff7518;
--green: #398439;
--teal: #20c997;
--cyan: #5bc0de;
--gray: #6c757d;
--gray-dark: #343a40;
--primary: #1177d1;
--secondary: #ced4da;
--success: #398439;
--info: #5bc0de;
--warning: #f0ad4e;
--danger: #d43f3a;
--light: #f8f9fa;
--dark: #343a40;
}

a:link, a:visited, a:active {
  text-decoration: none;
  color: #204d74;
}

a:hover {
  color: #2d6ca2;
}

button {
  font-size: 1rem;
  vertical-align: middle;
}

button:hover {
  cursor: pointer;
}

button > i {
  margin-left: 6px;
  margin-right: 6px;
  font-size: 110%;
}

input {
  cursor: auto;
  -moz-box-sizing:content-box;
  -webkit-box-sizing: content-box;
  box-sizing: content-box;
  font-size: 0.9rem;
}

input[type="checkbox"] {
        margin-right: 6px;
}

input[type="text"], input[type="email"] {
  background-color: #f7f7f7;
  color: #666;
  border: 1px solid #ccc;
  padding: 5px;
  vertical-align: middle;
}

input[type="text"]:hover, input[type="email"]:hover {
  background-color: #fff;
}

input[type="number"] {
  border: 1px solid #ccc;
  padding: 5px;
}


input[type="button"], input[type="checkbox"] {
  cursor: pointer;
}

input[type="button"]:hover {
  color: #069;
}

input[type="file"] {
    display: none;
}


img {
  border: 0;
  vertical-align: middle;
}

progress[value] {
  width: 200px;
  height: 5px;
}

label {
  padding-left: .3em;
  font-weight: bold;
}

.container {
  margin: 16px;
  font-size: 110%;
}


#inaf-logo {
  width: 173px;
  margin: 1px 0;
}

.img-circle {
  border-radius: 50%;
  box-shadow: 0px 0px 3px 3px #ddd;
}

.shadow {
  -webkit-box-shadow: 3px 3px 5px 6px #ccc;
  box-shadow:         3px 3px 5px 6px #ccc;
}

.hdrdiv2 {
  width : 100%;
  text-align: left;
  padding: 0 1px;
  color: #fff;
  background-color: #186680;
  font-size: 1.2rem;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.logo-div {
  display: inline-block;
  vertical-align: middle;
  padding: 8px;
  margin-top: 1px;
  background: #f7f7f7;
  border-top-right-radius: 36px;
}

.contact-info {
  float: right;
  font-size: .9rem;
  position: relative;
  top: 40px;
  right: 1em;
}

.submit_grey {
  font-weight: normal;
  background-image: linear-gradient(to bottom,#fff 0,#e0e0e0 100%);
  background-repeat: repeat-x;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.15),0 1px 1px rgba(0,0,0,0.075);
  color: #333;
  background-color: #fff;
  display: inline-block;
  padding: 6px;
  margin-bottom: 0;
  text-align: center;
  white-space: nowrap;
  vertical-align: middle;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submit_grey:hover {
  cursor: pointer;
  background-image: none;
  background-color: #e0e0e0;
  border: 1px solid #adadad;
}

.p_btn {
  border: none;
  border-bottom: 2px solid #ccc;
  color: #333;
  padding: 5px 10px;
  text-align: center;
  margin: 4px 2px;
  cursor: pointer;
  min-width: 2rem;
}

.p_btn:hover {
  background-color: #ddd;
}

.p_btn-selected {
  background-color: #fff;
  border-bottom: 2px solid #69c;
}

.page_top_tbar {
  background-color: #f7f7f7;
  color: #666;
  border-bottom: 1px solid #bdbec2;
  border-left: 1px solid #186680;
  border-right: 1px solid #186680;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}


.simple_button {
  padding: 3px 0;
  margin-left: 1rem;
  border: 1px solid #adadad;
  border-radius: 4px;
}

.simple_button:hover {
  background-color: #ddd;

  -webkit-transition: all 0.3s ease-in-out;
     -moz-transition: all 0.3s ease-in-out;
          transition: all 0.3s ease-in-out;
}

.transp_button {
  padding: 0;
  width: 2.5em;
  height: 2.5em;
  margin-left: 0.5rem;
  border: 1px solid #e6e6e6;
  border-radius: 50%;
  background-color: transparent;
  box-shadow: inset 0 0 0 1px #fff;
  transition: box-shadow 0.25s linear;
}

.transp_button:hover {
  box-shadow: inset 0 0 0 1.2em #eaeaea;
}

.label-range-in {
  margin-left: 0.5em;
  margin-right: 0.2em;
  font-size: inherit;
  font-weight: 600;
}

.range-in {
  max-width: 4em;
}


#chartdiv {
  width : 98%;
  height: 640px;
  overflow: hidden;
  text-align: left;
}

#res_legenddiv {
  display: inline-block;
  height: 34px;
  width: 120px;
  vertical-align: middle;
}

.box-resid-in {
  margin: 0.5em;
  padding-right: 4px;
  background: #efefef;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.box-cb {
  display: inline-block;
  margin-left: 1em;
  padding-right: .5em;
  background: #efefef;
  border: 1px solid #ddd;
  border-radius: 4px;
  vertical-align: middle;
}

#controls-div {
  margin-top: 0.5em;
}

#f_status, #range-selector-div {
  display: inline-block;
  margin-left: 1em;
}


section {
  overflow-x: hidden;
}

div.row {
  clear: both;
  border: 0px;
  padding: 0px;
}

div.section {
  clear: both;
  border: 0px;
  padding: 24px 0px;
  font-size: 110%;
  color: #444;
}

div.summ-div {
  margin-top: 1rem;
  border: 0;
  padding: 0;
}

div.summ-div-col {
  display: inline-block;
  margin-left: 1rem;
}

div.summ-div-col ul {
  list-style-type:none;
}

div.summ-div-col div {
  line-height: 1.8rem;
}

.fres-fixw {
  display: inline-block;
  width: 5rem;
  text-align: left;
}

.fres-int {
  display: inline-block;
  text-align: right;
  min-width: 3rem;
  font-weight: bold;
}

.fres-float {
  display: inline-block;
  text-align: left;
  min-width: 3rem;
  font-weight: bold;
  padding-left: 0.5rem;
}

div.trailer {
  height: 6px;
  line-height: 6px;
  background-color: #006699; /* #007ba6; */
  color: #999;
  border-left: 1px solid #186680;
  border-right: 1px solid #186680;
}

div.trailer a {
  text-decoration: none;
  color: #999;
}

div.trailer a:hover {
  color: #535353;
}


caption { 
  display: table-caption;
  text-align: center;
  padding-bottom: 20px;
  padding-top: 10px;
}


table, td, th {
  border: solid 1px #ddd;
  border-collapse: collapse;
  padding: 4px 6px;
  vertical-align: top;
}

th {
  text-align: center;
  font-weight: bold;
  background-color: #eaeaea;
}

td.highlight_blue {
  font-weight: bold;
  color: blue;
}



#pre_sel-div {
  font-size: 1rem;
  font-weight: bold;
  margin: 0.2rem 0.5rem;
}

#file_io-div {
  margin: 0.2rem 0.5rem;
}

/* Components parameters tooltip text */
.partip {
  transition: border .2s, background-color .2s;
  right: 0;
  position: relative;
}

.partip .partiptext {
  visibility: hidden;
  background-color: #555;
  color: #fff;
  text-align: left;
  border-radius: 6px;
  padding: 8px;
  position: absolute;
  z-index: 1;
  bottom: 110%;
  left: 0;
  opacity: 0;
  transition: opacity 0.3s;
  font-size: 1rem;
}

.partip .partiptext::after {
  content: "";
  position: absolute;
  top: 100%;
  left: 10%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
  border-color: #555 transparent transparent transparent;
}

.partip:hover .partiptext {
  visibility: visible;
  opacity: 1;
  transition: All 0.3s ease;
}

/* The Modal (background) */
.modal {
  position: fixed; /* Stay in place */
  z-index: 10; /* Sit on top */
  left: 0;
  top: 0;
  width: 100%; /* Full width */
  height: 100vh; /* Full height */
  overflow: auto; /* Enable scroll if needed */
  max-height: 100vh;  /* screen.height * .80; */
  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
/*
  animation-fill-mode: forwards;
*/
}

.modal.modal-slidein {
  animation-duration: 0.5s;
  animation-name: slidein;
  animation-timing-function: linear;
}

.modal.modal-slideout {
/*
  animation: 2s ease-in-out 0.2s slideout;
  box-shadow: none;
  top: -20px;
*/
  background-color: rgba(255, 255, 255, 0.0);
  height: 0;
  overflow: hidden;
  transition-property: all;
  transition-duration: 0.5s;
  transition-timing-function: ease-in-out;
  transition-delay: 0s;
}

.modal.modal-hide {
  height: 0;
  overflow: hidden;
  transition-property: all;
  transition-duration: 1s;
  transition-timing-function: ease-in-out;
  transition-delay: 0.2s;
}


/* Modal content */
.modal-content {
  position: relative;
  background-color: #fefefe;
  margin: 1rem auto;
  padding: 0;
  border: 1px solid #888;
  width: 90%;
  height: 80%;
  box-shadow: 0 4px 8px 0 rgba(0,0,0,0.5),0 6px 20px 0 rgba(0,0,0,0.2);
}

.modal-content.modal-fadein {
  animation-duration: 0.5s;
  animation-name: fadeIn;
}

.modal-content.modal-fadeout {
  animation-duration: 0.5s;
  animation-name: fadeOut;
}

.modal-header {
  padding: 0.01rem 1rem;
  background-color: #6699cc;  /*#5cb85c;*/
  color: #fff;
  font-size: 1.3rem;
}

.modal-body {
  /*height: 80vh; */
  height: inherit;
  padding: 2px 16px;
  overflow: auto; /* Enable scroll if needed */
}

.modal-body th:hover {
  background-color: #6699cc;
}

#dropzone {
  display: table;
  width: 90%;
  height: 85%;
  margin: auto;
  border: 4px dashed grey;
  background-color: #fff;
  text-align: center;
  line-height: 3rem;
  font-size: 1.5rem;
  margin-top: 1rem;
  margin-bottom: 1rem;
}

#dropzone > div {
  display: table-cell;
  vertical-align: middle;
  padding: 1rem;
}

#dropzone > div > input {
  cursor: pointer;
}



/* The Close button */
.close {
  color: #fff;
  float: right;
  font-size: 40px;
  font-weight: 300;
  margin-top: 12px;
  padding: 0px 4px 10px 4px;
  border: 3px solid #fff;
  border-radius: 18px;
}

.close:hover,
.close:focus {
  color: #000;
  text-decoration: none;
  cursor: pointer;
}


div .visible {
  z-index: 2;
  display: block;
  opacity: 1;
  height: auto;
    -webkit-transition: all 0.60s ease-out;
       -moz-transition: all 0.60s ease-out;
            transition: all 0.60s ease-out;
}

div .hidden {
  opacity: 0; 
  height: 0;
visibility: hidden;
  overflow: hidden;
    -webkit-transition: all 0.60s ease-in;
       -moz-transition: all 0.60s ease-in;
            transition: all 0.60s ease-in;
}


#p_title {
  color: #666;
  font-size: 1.2rem;
}

div.interface
{
  border-left: 1px solid #186680;
  border-right: 1px solid #186680;
  padding: 3px 8px;
}


/* Gradient color1 - color2 - color1 */
hr.style-one {
  border: 0; height: 1px; background: #fff;
  background-image: linear-gradient(to right, #f00, #0f0, #00f);
}

/* Gradient transparent - color - transparent */
hr.style-two {
  border: 0; height: 1px;
  background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
}

.custom-file-select {
  border: 1px solid #ccc;
  border-radius: 4px;
  display: inline-block;
  padding: 6px 12px;
  cursor: pointer;
  line-height: 2rem;
}

.custom-file-select:hover {
  background: #ddd;
  cursor: pointer;
  text-decoration: none;
  -webkit-transition: all 0.30s ease-in;
     -moz-transition: all 0.30s ease-in;
          transition: all 0.30s ease-in;
}


#fitlog_sect {
  font-size: 1.5em;
  font-weight: 500;
}

#fitlog_tab {
  width: auto;
  white-space: nowrap;
  margin-left: 1rem;
  font-size: 1rem;
}

.header-lab {
  font-size: 1em;
  font-weight: bold;
  padding: 1em 0;
}

.out_table {
  border: 0;
  border-left: 3px solid #ddd;
  padding-left: 1em;
  padding-top: 1em;
}

.toggle_table-hdr {
  border-bottom: 1px solid #ddd;
  padding: 1em;
  font-size: 1.1em;
  font-weight: 600;
}

.toggle_table-hdr:hover {
  background-color: #eaeaea;
  cursor: pointer;
  color: #069;
  -webkit-transition: all 0.30s ease-in;
     -moz-transition: all 0.30s ease-in;
          transition: all 0.30s ease-in;
}

.inline {
  display: inline-block;
}

.inline-div {
  display: inline-block;
  vertical-align: middle;
  margin-left: 1rem;
}

.div-hide {
  display: none;
  visibility: hidden;
  height: 0;
}

.div-show {
  display: block;
  visibility: visible;
  height: auto;
}

.div-show-inline {
  display: inline-block;
  visibility: visible;
  height: auto;
}

.div-show_anim {
  display: block;
  visibility: visible;
  height: auto;
  animation: 1s linear 0s fadeIn;
  transition: height 1s 0.2s ease-in-out; 
}

.rep_div-show {
  display: block;
  visibility: visible;
  height: auto;
  animation: 1s linear 0s fadeIn;
  transition: height 1.5s 0.3s ease-in-out; 
  border-left: 3px solid #2d6ca2;
}

.div-selected {
  border-color: #069;
  border-left: 3px solid #2d6ca2;
  border-bottom: 0;
  background: #efefef;
}

.al-right {
  text-align: right;
}

.ud-angle {
  margin-right: 2rem;
}



/* Add Animation */
@keyframes slidein {
  from {top: -300px; visibility: hidden;}
  to {top: 0; visibility: visible;}
}

@keyframes slideout {
  from { transform: translateY(0); visibility: visible;}
  to   { transform: translateY(-300px); visibility: hidden;}
}

@keyframes fadeIn {
   0% { opacity: 0; visibility: hidden; }
 100% { opacity: 1; visibility: visible; }
}

@keyframes fadeOut {
    0% { opacity: 1; visibility: visible; }
  100% { opacity: 0; visibility: hidden; width: 100%; }
}
</style>


<!-- @Local
  <link href="./local/qsfit_logo.ico.gif" rel="shortcut icon" type="image/x-icon" />

  <script src="./local/amcharts_core.js"></script>
  <script src="./local/amcharts_charts.js"></script>
  <script src="./local/amcharts_animated.js"></script>
  <link href="./local/fontawesome/css/fontawesome.css" rel="stylesheet">
  <link href="./local/fontawesome/css/solid.css" rel="stylesheet">
-->

<!-- @Standalone -->

</head>

<body>

<div class="hdrdiv2">

  <div class="logo-div">
  <svg width="128" height="48" viewBox="0 0 156.5 61.2">
	<g transform="matrix(1.333,0,0,-1.333,-223.620,567.710)">
<g transform="translate(-1692,-1584)"><path
	d="m 1883.7977,1992.7143 c 5.1416,-4.167 5.9327,-11.7148 1.7666,-16.8593 -4.166,-5.1443 -11.7111,-5.9368 -16.853,-1.7698 -5.1416,4.1667 -5.9326,11.7148 -1.7666,16.8591 4.166,5.1446 11.7112,5.937 16.853,1.77 z"
	style="fill:#00adef;fill-opacity:1;fill-rule:nonzero;stroke:none"
	/><path
	d="m 1898.2428,2006.6033 -3.1782,-3.9246 -3.9224,3.179 3.1782,3.9245 z"
	style="fill:#1478c7;fill-opacity:1;fill-rule:nonzero;stroke:none"
	/><path
	d="m 1866.8156,1967.7952 -3.1783,-3.9246 -3.9226,3.1789 3.178,3.9246 z"
	style="fill:#1f4fa2;fill-opacity:1;fill-rule:nonzero;stroke:none"
	/><path
	d="m 1924.756,1978.2402 h 3.2151 v 11.0532 h -3.2151 z"
	style="fill:#63696e;fill-opacity:1;fill-rule:evenodd;stroke:none"
	/><path
	d="m 1932.778,1978.2402 h 2.8474 v 7.961 h 0.031 l 5.0064,-7.961 h 4.2561 v 11.0532 h -2.8477 v -7.9609 h -0.031 l -5.0369,7.9609 h -4.2253 z"
	style="fill:#63696e;fill-opacity:1;fill-rule:evenodd;stroke:none"
	/><path
	d="m 1958.5463,1982.4807 h -4.4551 l 2.2656,4.6694 z m -9.8286,-4.2405 h 3.3066 l 1.0718,2.1892 h 6.4299 l 1.041,-2.1892 h 3.5977 l -5.741,11.0532 h -3.8428 z"
	style="fill:#63696e;fill-opacity:1;fill-rule:evenodd;stroke:none"
	/><path
	d="m 1968.1,1978.2402 h 3.2151 v 4.1336 h 5.4196 v 2.2656 h -5.4196 v 2.2964 h 5.7409 v 2.3576 h -8.956 z"
	style="fill:#63696e;fill-opacity:1;fill-rule:evenodd;stroke:none"
	/></g></g>
  </svg>
  </div>

  <div class="inline-div">
    <div class="inline"><a style="color: #fff; font-weight: bold;" href="https://github.com/lnicastro/GFitViewer.jl" target="_new">GFitViewer</a> &minus;
      <span style="font-size: 1rem; font-style: italic; color: #ccc;">Version 0.1</span>
    </div>

    <div style="font-size: 1rem; margin-top: 0.5em;">A viewer for <a href="https://github.com/gcalderone/GFit.jl" style="color: #fff; font-weight: bold;" target="_new">GFit</a> 1D results </div>

  </div>

  <div class="contact-info"><a style="color: #ccc;" href="mailto:luciano.nicastro@inaf.it">L. Nicastro</a> &amp; <a style="color: #ccc;"  href="mailto:giorgio.calderone@inaf.it">G. Calderone</a> 2020-21</div> 

</div>


<section class="page_top_tbar">

  <div id="pre_sel-div" class="div-hide">
	Select dataset # <span id="p_selector"></span>
  </div>

  <div id="file_io-div" class="div-hide">
    <button class="submit_grey" type="submit" onclick="openLoadDiv()" id="myBtn"><i class="fas fa-file-import"></i>Load file</button>
    <button id="viewbutton" class="simple_button" style="padding-right: 0.2em;" title="Retrieve full JSON data" onclick="savejsonobj('gfit_data.json', chart_data)">
      <i class="fas fa-download" aria-hidden="true"></i>JSON data
    </button>
    <span id="json_info" style="margin-left: 0.5em; font-weight: bold;">Data file info...</span>
  </div>

</section>


<div class="interface">

  <div id="myModal" class="modal modal-hide">
<!-- Modal content -->
    <div id="myModal_cont" class="modal-content">

	    <div class="modal-header">
		<span class="close" title="Close">&times;</span>
		<h3 class="modal-header-text">GFitViewer file selector ...</h3>
	    </div>

	    <div id="modal-logdiv" class="modal-body">

		<div id="dropzone">
		  <div>
			Drag &amp; drop a GFit file here...
			<br />or<br />
			<label for="selfile" class="custom-file-select"><i class="fas fa-search" style="padding-right: .5rem;"></i>Browse ...</label>
			<input id="selfile" type="file" accept=".json" />
		  </div>
		</div>

		<progress value="0" max="100" id="progress-bar"></progress>
		<div id="f_status"></div>
	    </div>

    </div>
  </div>

  <section style="margin-top: 0.5em;">
	<span id="p_title">GFitViewer info here...</span>

  </section>


  <div id="chartdiv"></div>


<div class="box-resid-in" style="float: right;">
  <div id="res_legenddiv"></div>

	<span style="vertical-align: middle;" title="Set the highlighted resid. range"> &pm; N&sigma;
	  <input type="number" style="width: 2.5rem;" min="1.0" max="30.0" step="0.1" name="n_sigma" id="n_sigma" value="3.0" onchange="n_sigma_update(this)" />
	</span>
</div>


  <div id="controls-div">
<!--
	<span class="box-cb" title="Toggle Y errors plot">
	  <input type="checkbox" id="y_err-cb" onclick="y_err_toggle()" /><label for="y_err-cb">Y err</label>
	</span>
-->
	<span class="box-cb" title="Track and display cursor position coordinates">
	  <input type="checkbox" id="cursor-cb" onclick="cursor_toggle()" /><label for="cursor-cb">Track cursor</label>
	</span>
	<span class="box-cb" title="Toggle X lin/log scale">
	  <input type="checkbox" id="x_log-cb" onclick="x_linlog_toggle()" /><label for="x_log-cb">X log</label>
	</span>

	<span class="box-cb" title="Toggle Y lin/log scale">
	  <input type="checkbox" id="y_log-cb" onclick="y_linlog_toggle()" /><label for="y_log-cb">Y log</label>
	</span>

	<div id="range-selector-div">
	  <span class="label-range-in">X range</span><input name="xmin" type="text" class="range-in" value="" onchange="xy_range_set()" />
	  <input name="xmax" type="text" class="range-in" value="" onchange="xy_range_set()" />
	  <span class="label-range-in" style="margin-left: 1em;">Y range</span><input name="ymin" type="text" class="range-in" value="" onchange="xy_range_set()" />
	  <input name="ymax" type="text" class="range-in" value="" onchange="xy_range_set()" />

	  <button class="transp_button" style="color: var(--success);" title="Replot with these ranges" onclick="xy_range_set()">
          <i class="far fa-check-circle" aria-hidden="true"></i>
	  </button>
<!--
	<button class="transp_button" style="color: #1177d1;" title="Reset ranges" onclick="xy_range_reset()">
        <i class="fas fa-times" aria-hidden="true"></i>
	</button>
-->
	  <button class="transp_button" style="color: var(--danger);" title="Clear range input values" onclick="xy_range_reset()">
	  <i class="fas fa-times" aria-hidden="true"></i>
	  </button>
	</div>
<!--
	<div style="display: block; float: right; margin-top: 1rem; color: #999;">
	plot made using <a href="https://amCharts.com/" target="_new">amCharts</a>
	</div>
-->

  </div> <!-- controls-div -->

<hr class="style-one"></hr>

<div class="toggle_table-hdr" id="fitlog_sect" onclick="fitlog_toggle()">
  <i id="view_fitlog_angle" class="fas fa-angle-down ud-angle"></i>GFit report
</div>

<div id="fitlog_div" class="div-hide">
  <div id="fitlog_tab">ALL THE FIT SUMMARY TABLES TO BE DISPLAYED HERE</div>
</div>

  <script>
    var chart_data = JSON_DATA;
  </script>

<script type="text/javascript">

// Initialize metadata and local variables
  var   n_sigma = 3,		// Highlight residuals region within this +/- sigma
	y_errplot = false,	// Y errors plot
	y_err_shade = false,	// Y errors shaded area
	x_logscale = false,	// X lin/log scale
	y_logscale = false,	// Y lin/log scale
	cur_track = false,	// Track cursor and display X, Y values
	am_anim = false,	// Animation theme ?
	x_range = {lin: {min: null, max: null}, log: {min: null, max: null}},  // lin/log X ranges
	y_range = {lin: {min: null, max: null}, log: {min: null, max: null}},  // lin/log Y ranges
	chart = {},	// The amchart object
	sdata = [],	// The data series to plot (with errors)
	serr = [],	// The Y errors shaded area series
	resid = [],	// The residuals
	aux = {},	// The metadata information read from the JSON file and more,
	vxAxis,		// X axis object
	valueAxis,	// Y axis object
	valueAxis2,	// The residuals right axis object
	cur_container,  // The cursor Container
	curXY,		// The text Label in the cursor Container
	legend2,	// The second legend used for residuals
	range, range2,	// Used to highlight +/- N sigma residuals

	p_title = document.getElementById('p_title'),
	xyin_ranges = document.getElementById('range-selector-div').getElementsByTagName('input');


// A set of 19 colors + white + black
// grey, blue and darkblue removed and used by def. for the data, main reducer and residuals array
  var mycolors = [
        {'name':'Red', 'hex':'#e6194b', 'rgb':'(230, 25, 75)', 'rgba':'(230, 25, 75, 0.5)'},
        {'name':'Green', 'hex':'#3cb44b', 'rgb':'(60, 180, 75)', 'rgba':'(60, 180, 75, 0.5)'},
        {'name':'Purple', 'hex':'#911eb4', 'rgb':'(145, 30, 180)', 'rgba':'(145, 30, 180, 0.5)'},
        {'name':'Orange', 'hex':'#f0ad4e', 'rgb':'(240, 173, 78)', 'rgba':'(240, 143, 78, 0.5)'},
        {'name':'Magenta', 'hex':'#f032e6', 'rgb':'(240, 50, 230)', 'rgba':'(240, 50, 230, 0.5)'},
        {'name':'Teal', 'hex':'#008080', 'rgb':'(0, 128, 128)', 'rgba':'(0, 128, 128, 0.5)'},
        {'name':'Orange2', 'hex':'#ff7518', 'rgb':'(255, 117, 24)', 'rgba':'(255, 117, 24, 0.5)'},
        {'name':'Lavender', 'hex':'#e6beff', 'rgb':'(230, 190, 255)', 'rgba':'(230, 190, 255, 0.5)'},
        {'name':'Brown', 'hex':'#aa6e28', 'rgb':'(170, 110, 40)', 'rgba':'(170, 110, 40, 0.5)'},
        {'name':'Maroon', 'hex':'#800000', 'rgb':'(128, 0, 0)', 'rgba':'(128, 0, 0, 0.5)'},
        {'name':'Olive', 'hex':'#808000', 'rgb':'(128, 128, 0)', 'rgba':'(128, 128, 0, 0.5)'},
        {'name':'Coral', 'hex':'#ffd8b1', 'rgb':'(255, 215, 180)', 'rgba':'(255, 215, 180, 0.5)'},
        {'name':'Navy', 'hex':'#000080', 'rgb':'(0, 0, 128)', 'rgba':'(0, 0, 128, 0.5)'},

        {'name':'Pink2', 'hex':'#F0AAAA', 'rgb':'(240, 170, 170)', 'rgba':'(240, 170, 170, 0.5)'},
        {'name':'Mint2', 'hex':'#96E6B4', 'rgb':'(150, 230, 180)', 'rgba':'(150, 230, 180, 0.5)'},
        {'name':'Yellow', 'hex':'#FFD700', 'rgb':'(255, 215, 0)', 'rgba':'(255, 215, 0, 0.5)'},
        {'name':'Cyan2', 'hex':'#60C8E8', 'rgb':'(96, 200, 232)', 'rgba':'(96, 200, 232, 0.5)'},
        {'name':'Beige2', 'hex':'#E6D7B4', 'rgb':'(230, 215, 180)', 'rgba':'(230, 215, 180, 0.5)'},
        {'name':'Lime2', 'hex':'#C3E61E', 'rgb':'(195, 230, 30)', 'rgba':'(195, 230, 30, 0.5)'},

        {'name':'White', 'hex':'#FFFFFF', 'rgb':'(255, 255, 255)', 'rgba':'(255, 255, 255, 0.5)'},
        {'name':'Black', 'hex':'#000000', 'rgb':'(0, 0, 0)', 'rgba':'(0, 0, 0, 0.5)'}
  ], n_myc = 19,

// Data color
  dcolor = {'name':'Grey', 'hex':'#808080', 'rgb':'(128,128,128)', 'rgba':'(128,128,128, 0.5)'},

// Main reducer color
  mcolor = {'name':'Blue', 'hex':'#0082c8', 'rgb':'(0, 130, 200)', 'rgba':'(0, 130, 200, 0.5)'},

// Residuals color
  rcolor = {'name':'Darkblue', 'hex':'#386cb0', 'rgb':'(56,108,176)', 'rgba':'(56,108,176, 0.5)'};


// Manage URL parameters
  var c_ipre = 0;		 // Currently plotted prediction index
  var interface_type = 'basic';	 // Default interface type

  if ( window.location.search !== '' ) {
    const urlParams = new URLSearchParams(window.location.search);

// Check for the initial prediction to show (default 0)
  if ( urlParams.has('prediction') )
	c_ipre = urlParams.get('prediction') - 1;


// Check for the interface type: basic (default), fileio, more TODO
  if ( urlParams.has('mode') )
	interface_type = urlParams.get('mode');
  }


  if ( interface_type == 'fileio' ) {
	document.getElementById('file_io-div').setAttribute('class', 'div-show-inline');
	document.getElementById('myModal').className = 'modal';
 }


// Format numbers > 1000 adding the "," separator

const numberWithCommas = (x) => {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


// Compute the number of fractional "significant" digits in sequential values from the given (~constant) step

const nfSignificant = (x) => {
  return Math.max((Math.abs(x) % 1).toPrecision(1).length - 2, 0);
}

// Format the parameters range at a given digits precision

pRange = function(low, high, np) {
  if ( low === null && high === null )
    return '';

  if ( np === undefined )
    np = 4;

  if ( low === undefined || typeof low !== 'number' )
    v = '-Inf';
  else {
    v = low;
    if ( ! Number.isInteger(v) )
	v = +v.toPrecision(np);  // To number to remove trailing 0s
  }
  if ( high === undefined || typeof high !== 'number' )
    v += ':Inf';
  else {
    var v2 = high;
    if ( ! Number.isInteger(v2) )
	v2 = +v2.toPrecision(np);
    v += ':'+ v2;
  }
  return v;
}


// Hidden object?

function isHidden(e) {
	return (e.offsetParent === null)
}


// -- Open the file load modal div

function openLoadDiv() {
// Get the button that opens the modal
//var btn = document.getElementById("myBtn");

// When the user clicks the button, open the modal 
  showLoadDiv();

// Clean progress bar and load status message
  document.getElementById('progress-bar').value = 0;
  f_changeStatus('');

// Get the span element that hides the modal
  var span = document.getElementsByClassName('close')[0];

// When the user clicks on span (x), hide the modal
  span.onclick = function() {
	hideLoadDiv();
  }

// When the user clicks anywhere outside of the modal, hide it
  window.onclick = function(event) {
    var modal = document.getElementById('myModal');
    if ( event.target == modal )
	hideLoadDiv();
  }
}


// -- Show the modal div

function showLoadDiv() {
  var modal = document.getElementById('myModal');
  modal.className = 'modal modal-slidein';
}


// -- Hide the modal div

function hideLoadDiv() {
  var modal = document.getElementById('myModal');
  modal.className = 'modal modal-slideout';
}


//
// -- Files drop management

window.onload = function() {
	var dropzone = document.getElementById('dropzone');
	dropzone.ondragover = dropzone.ondragenter = function(event) {
		event.stopPropagation();
		event.preventDefault();
	}

	dropzone.ondrop = function(event) {
		event.stopPropagation();
		event.preventDefault();

		var filesArray = event.dataTransfer.files;
		for (i = 0; i < filesArray.length; i++)  // Actually here should limit to 1 file!
			processFile(filesArray[i]);
	}
}


//
// -- Files loading listening to "selfile" element change

document.getElementById('selfile').addEventListener('change', (e) => {
	const file = document.getElementById('selfile').files[0];
	if ( file )
	  processFile(file);
});


// A basic error handler for FileReader

const f_errorHandler = (e) => {
	f_changeStatus("Error: "+ e.target.error.name);
}


// Updates the value of the progress bar

const f_setProgress = (e) => {
// The target is the file reader
	const fr = e.target;
	const loadingPercentage = 100 * e.loaded / e.total;
	document.getElementById('progress-bar').value = loadingPercentage;
}

const f_changeStatus = (status) => {
	document.getElementById('f_status').innerHTML = status;
}


// Manage local file upload

const processFile = (file) => {
	const fr = new FileReader();
	fr.readAsText(file);
	fr.onprogress = f_setProgress;
	fr.onerror = f_errorHandler;
	fr.onabort = () => f_changeStatus('Start Loading');
	fr.onloadstart = () => f_changeStatus('Start Loading');
	fr.onload = f_loadedOk;
	fr.onloadend = () => fileInfo(file);

// At this point we can also perform some operations on the data asynchronously
}


// Display file info in the interface, considering data origin (local or web)

const fileInfo = (file) => {
	document.getElementById('progress-bar').value = 100;
	f_changeStatus('Loaded!');
	var fname, size_info = 'Loaded <strong>';
	if ( typeof file === 'object' ) {
		document.getElementById('json_info').innerHTML = file.name;
		size_info += numberWithCommas(chart.data.length) +'</strong> elements';
	} else if ( typeof file === 'string' ) {
		document.getElementById('json_info').innerHTML = file.split('/').reverse()[0];
		size_info += numberWithCommas(chart.dataSource.data.length) +'</strong> elements array';
	}
}


// Loading completed successfully; pass the data to chart

const f_loadedOk = (e) => {
	const fr = e.target;
	chart_data = JSON.parse(fr.result);
	c_ipre = 0;  // Reset the prediction(s) index

	getauxinfo();

	p_select(0, true);
	hideLoadDiv();
}



//
// -- Extract and manage the metadata info

var getauxinfo = function() {  // TODO

// Multiple predictions for the same "object" are allowed (TODO)
  aux.n_p = chart_data.predictions.length;
  aux.n_d = (chart_data.data !== undefined) ? chart_data.data.length : 0;
  aux.preinfo = [];
  aux.preinfo.length = 0;
  aux.datinfo = [];
  aux.datinfo.length = 0;

  var cnames, rnames, desc, x_lab, y_lab, n_x, x_step;

  for (var i = 0; i < aux.n_p; i++) {
    cnames = Object.keys(chart_data.predictions[i].components);
    rnames = Object.keys(chart_data.predictions[i].reducers);

    n_x = chart_data.predictions[i].x.length;

    desc = '<span style="color: #69c; font-weight: bold;">'+ chart_data.predictions[i].meta.label +'</span> &minus; ';
    if ( aux.n_d > 0 && chart_data.data[i] !== undefined )
	desc += chart_data.data[i].meta.label;
    else
	desc += 'None';

    desc += ' &minus; rebin factor: '+
	    chart_data.predictions[i].meta.rebin;

    x_lab = chart_data.predictions[i].meta.label_x;
    if ( x_lab !== '' ) {
	x_lab += ' ('; 
	var un = chart_data.predictions[i].meta.scale_x.toString().replace(/\+/,'');
	if ( un !== '1' )
		x_lab += un +'X ';
	x_lab += chart_data.predictions[i].meta.unit_x +')';
    } else
	x_lab = 'X label';
    
    y_lab = chart_data.predictions[i].meta.label_y;
    if ( y_lab !== '' ) {
	y_lab += ' ('; 
	var scale = chart_data.predictions[i].meta.scale_y.toString().replace(/\+/,'');
	if ( scale !== '1' ) {
/* This is TODO
		var ep = scale.indexOf('e');
		if ( ep > 0 && ep < scale.length - 1 ) {
			var ee = scale.split('e');
			scale = ee[0] + '[vertical-align: super; font-size: 70%;]' + ee[1] +'[/]';
		}
*/
		y_lab += scale +' ';
	}
	y_lab += chart_data.predictions[i].meta.unit_y +')';
    } else
	y_lab = 'Y label';
    
    x_step = Math.abs(chart_data.predictions[i].x[1] - chart_data.predictions[i].x[0]);

    aux.preinfo.push({
	title: desc,
	x_label: x_lab,
	y_label: y_lab,
	x_min: chart_data.predictions[i].x[0],
	x_max: chart_data.predictions[i].x[n_x - 1],
	y_min: Math.min(...(chart_data.predictions[i].folded_model)),
	y_max: Math.max(...(chart_data.predictions[i].folded_model)),
	x_step: x_step,
	nf_sig: nfSignificant(x_step),
	components: cnames,
	n_comps: cnames.length,
	reducers: rnames,
	n_reds: rnames.length,
	main_reducer: chart_data.predictions[i].main_reducer  // TODO - will be removed
    });

// Equidistance check (TODO)
    aux.preinfo[i].x_equi = Math.abs((aux.preinfo[i].x_max - aux.preinfo[i].x_min)/(n_x-1) - x_step) < 0.001;
  }  // end for


// The prediction selector
  var b, ss = document.getElementById('p_selector'),
	d = document.getElementById('pre_sel-div');
  ss.innerHTML = '';

// Create only if more than one prediction
  if ( aux.n_p < 2 )
    d.setAttribute('class', 'div-hide');

  else {
    d.setAttribute('class', 'div-show-inline');
    for (var i = 0; i < aux.n_p; i++) {
	b = document.createElement('button');
	b.setAttribute('type', 'button');
	b.setAttribute('class', 'p_btn');
	b.setAttribute('onclick', 'p_select('+ i +')');
	b.setAttribute('id', 'pred_'+ i);
	b.innerHTML = ' '+ (i+1).toString() +' ';
 	ss.appendChild(b);
    }
  }
  
  for (var i = 0; i < aux.n_d; i++) {
	aux.datinfo.push({
	  resid_visible: (chart_data.data[i].meta.resid_visible || false),
	  resid_color: (chart_data.data[i].meta.resid_color || rcolor.hex)}
	);  // TODO
  }

  p_title.innerHTML = aux.preinfo[c_ipre].title;
}


//
// -- From custom "data/components/reducers" structures to default amchart data structure

var mydata2chart = function(isel) {
  if ( isel === undefined )
    isel = c_ipre;

console.log('isel:', isel);
  var p = chart_data.predictions[isel],
	cnames = aux.preinfo[isel].components,
	rnames = aux.preinfo[isel].reducers,
	fscale = Math.pow(10, aux.preinfo[isel].nf_sig),
	mydata = [], vals = {};

// X values rounded to the N sig. factional digits
  for (var i = 0; i < p.x.length; i++) {
	vals = {};
	vals['x'] = Math.round(p.x[i] * fscale) / fscale;
	if ( aux.n_d > 0 ) {
	  vals['y'] = chart_data.data[isel].y[i];
	  vals['error'] = chart_data.data[isel].err[i];
	  vals['resid'] = chart_data.data[isel].residuals[i];

	  vals['err_lo'] = chart_data.data[isel].y[i] - chart_data.data[isel].err[i];
	  vals['err_up'] = chart_data.data[isel].y[i] + chart_data.data[isel].err[i];
	}

	vals['folded_model'] = p.folded_model[i];  // Folded model

	for (var j = 0; j < aux.preinfo[isel].n_reds; j++) {  // Reducers
          if ( !p.reducers[rnames[j]].meta.use_in_plot )
		continue;
	  //if ( p.reducers[rnames[j]].y[i] > 0 )
	  vals[rnames[j]] = p.reducers[rnames[j]].y[i];
	}

	for (var j = 0; j < aux.preinfo[isel].n_comps; j++) { // Components
          if ( !p.components[cnames[j]].meta.use_in_plot )
		continue;
	  //if ( p.compevals[cnames[j]].y[i] > 0 )
	  vals[cnames[j]] = p.compevals[cnames[j]].y[i];
	}

	mydata.push(vals);
  }

  return mydata;
}


//
// -- Create series for the the main reducer of a prediction.
//    2021/03/24: Changed to folded_model
//    If xsc_series=true, use it also for the X window scrolling. 

function createMainReducer(isel, xsc_series) {
  if ( isel === undefined )
    isel = c_ipre;

  var hs;

console.log('Create "folded_model" model');

  var series = chart.series.push(new am4charts.LineSeries());
  series.dataFields.valueX = 'x';
  series.dataFields.valueY = 'folded_model';

  series.name = 'Prediction';
  series.strokeWidth = 2;
  series.legendSettings.labelText = 'Prediction [#fff]______[/]';

  if ( chart_data.predictions[isel].meta.color !== 'auto' ) {  // User selected color?
    series.stroke = chart_data.predictions[isel].meta.color;
    series.fill = chart_data.predictions[isel].meta.color;
  } else {
    series.stroke = mcolor.hex;
    series.fill = mcolor.hex;
  }


// Highlight when cursor on legend item
  hs = series.segments.template.states.create("hover");
  hs.properties.strokeWidth = 5;

  if ( xsc_series !== undefined && xsc_series == true )
    chart.scrollbarX.series.push(series);
}


//
// -- The data series

function createDataSeries(isel) {
  if ( isel === undefined )
    isel = c_ipre;

// No data, just the model. Create and return.
  if ( aux.n_d == 0 ) {
    createMainReducer(isel, true);
    return;
  }

  var hs;
  sdata = [];
  sdata = chart.series.push(new am4charts.LineSeries());
  sdata.dataFields.valueX = 'x';
  sdata.dataFields.valueY = 'y';
  sdata.name = 'data';  // chart_data.meta.data.label;
  sdata.legendSettings.labelText = 'Data';
  sdata.strokeWidth = 2;


// User selected color?
  if ( chart_data.data[isel].meta.color !== 'auto' ) {
    sdata.stroke = chart_data.data[isel].meta.color;
    sdata.fill = chart_data.data[isel].meta.color;
  } else {
    sdata.stroke = dcolor.hex;
    sdata.fill = dcolor.hex;
  }
 
// The shaded errors range
  serr = chart.series.push(new am4charts.LineSeries());
  serr.dataFields.valueX = 'x';
  serr.dataFields.openValueY = 'err_lo';
  serr.dataFields.valueY = 'err_up';
  serr.name = 'uncert';
  serr.legendSettings.labelText = 'Uncert.';
  serr.fillOpacity = 0.3;
  serr.fill = sdata.fill;
  serr.stroke = am4core.color("#ffffff00");;  // White (transparent) top line
  serr.visible = false;  // Hidden by default


// Highlight when cursor on legend item
  hs = sdata.segments.template.states.create("hover");
  hs.properties.strokeWidth = 5;

// Error bars (unused)
/*
  errorBullet = sdata.bullets.create(am4charts.ErrorBullet);
  errorBullet.isDynamic = true;
  errorBullet.strokeWidth = 1;
  errorBullet.width = 1;

// Adapter adjusts height of a bullet
  errorBullet.adapter.add("pixelHeight", function(pixelHeight, target) {
    var dataItem = target.dataItem;

    if ( dataItem ) {
        var value = dataItem.valueY;
        var errorTopValue = value + dataItem.dataContext.error;
        var errorTopY = valueAxis.valueToPoint(errorTopValue).y;

        var errorBottomValue = value - dataItem.dataContext.error;
        var errorBottomY = valueAxis.valueToPoint(errorBottomValue).y;

        return Math.abs(errorTopY - errorBottomY);
    }
    return pixelHeight;
  });
*/

  chart.scrollbarX.series.push(sdata);


// -- Main Reducer always first (and before residuals and the components)

  createMainReducer(isel);


// -- Residuals, if they exist

  if ( typeof sdata.residuals !== undefined ) {
    resid = chart.series.push(new am4charts.LineSeries());
    resid.dataFields.valueX = 'x';
    resid.dataFields.valueY = 'resid';
    resid.name = 'Residuals';  // chart_data.data.meta.resid_label;
    resid.yAxis = valueAxis2;
    resid.strokeWidth = 2;
    resid.hiddenInLegend = true;  // Not in the default legend


// Visible?
    sdata.resid_visible = aux.datinfo[isel].resid_visible;

    if ( sdata.resid_visible ) {
	range.grid.strokeOpacity = 0.5;
	range2.axisFill.fillOpacity = 0.1;
	//valueAxis.renderer.grid.template.strokeOpacity = 0;
	valueAxis2.renderer.ticks.template.strokeOpacity = 1;
    } else {
	valueAxis2.visible = false;
	valueAxis2.cursorTooltipEnabled = false;
	resid.visible = false;

	range.grid.strokeOpacity = 0;
	range2.axisFill.fillOpacity = 0; 
    }

  
// User selected color?
    if ( aux.datinfo[isel].resid_color !== 'auto' ) {
	resid.stroke = aux.datinfo[isel].resid_color;
	resid.fill = aux.datinfo[isel].resid_color;
    } else {
	resid.stroke = rcolor.hex;
	resid.fill = rcolor.hex;
    }

    legend2.data.push({name: resid.name, fill: resid.fill, visible: sdata.resid_visible});
    legend2.tooltipText = 'Show/hide residuals';
    legend2.tooltip.background.opacity = 0.7;
    legend2.tooltip.pointerOrientation = 'right';
    legend2.tooltip.dx = -56;

    var marker = legend2.markers.template.children.getIndex(0);
    legend2.useDefaultMarker = true;
    marker.width = 16;
    marker.height = 16;
    marker.strokeWidth = 2;
    marker.strokeOpacity = 1;
    marker.stroke = am4core.color("#ccc");


// Highlight when cursor on legend item
    legend2.itemContainers.template.events.on("over", function(ev) {
	resid.strokeWidth = 4;
    });

    legend2.itemContainers.template.events.on("out", function(ev) {
	resid.strokeWidth = 2;
    });


// Toggle residuals visibility in legend2
    legend2.itemContainers.template.events.on("hit", function(ev) {
//var field = ev.target.dataItem.dataContext, name = field.name;
	if ( resid.visible ) {
	  range.grid.strokeOpacity = 0;
	  range2.axisFill.fillOpacity = 0;
	  valueAxis2.renderer.ticks.template.strokeOpacity = 0;
	  valueAxis2.visible = false;
//valueAxis2.cursorTooltipEnabled = false;
	  resid.hide();
	} else {
	  n_sigma = +document.getElementById('n_sigma').value;
	  range2.value = -n_sigma;
	  range2.endValue = n_sigma;
	  range.grid.strokeOpacity = 0.5;
	  range2.axisFill.fillOpacity = 0.1;
	  valueAxis2.renderer.ticks.template.strokeOpacity = 1;
	  valueAxis2.visible = true;

	  valueAxis2.min = -n_sigma - 1;
	  valueAxis2.max = n_sigma + 1;
	  setTimeout(function() {
		valueAxis2.zoomToValues(-n_sigma - 1, n_sigma + 1);
//valueAxis2.cursorTooltipEnabled = true;
	  }, 200);
	  resid.show();
	}
	sdata.resid_visible = ! sdata.resid_visible;

console.log('zoom to:', x_range.lin.min, x_range.lin.max);
	setTimeout(function() {
	  if ( x_logscale ) {
	    if ( vxAxis.min !== x_range.log.min || vxAxis.max !== x_range.log.max )
		vxAxis.zoomToValues(x_range.log.min, x_range.log.max);
	  } else {
	    if ( vxAxis.min !== x_range.lin.min || vxAxis.max !== x_range.lin.max )
		vxAxis.zoomToValues(x_range.lin.min, x_range.lin.max);
	  }
	}, 100);
    });

  }  // end sdata.residuals


// Highlight when cursor on legend item
//hs = resid.segments.template.states.create("hover");
//hs.properties.strokeWidth = 5;
}


//
// -- Create series for each component and reducer of a prediction

function createCompSeries(isel) {
  if ( isel === undefined )
    isel = c_ipre;

  var	p = chart_data.predictions[isel],
	data = [], cname, rname, component, reducer, hs, icol = 0;

  vxAxis.title.text = aux.preinfo[isel].x_label;
  valueAxis.title.text = aux.preinfo[isel].y_label;

// -- Components
  for (var i = 0; i < aux.preinfo[isel].n_comps; i++) {  // Components in a prediction
	cname = aux.preinfo[isel].components[i];
	component = p.components[cname];
    
	if ( !component.meta.use_in_plot )  // Component has data?
	  continue;

console.log('Create component:', cname);
    
	var series = chart.series.push(new am4charts.LineSeries());
	series.dataFields.valueX = 'x';
	series.dataFields.valueY = cname;

	series.name = cname;
	series.strokeWidth = 2;

	if ( component.meta.color !== 'auto' ) {  // User selected color?
	  series.stroke = component.meta.color;
	  series.fill = component.meta.color;
	} else {
	  series.stroke = mycolors[icol % n_myc].hex;
	  series.fill = mycolors[icol % n_myc].hex;
console.log('  color:', mycolors[icol % n_myc].name, mycolors[icol % n_myc].hex);
	  icol++;
	}

	if ( !component.meta.default_visible )  // Component to hide?
	  series.visible = false;

// Highlight when cursor on legend item
	hs = series.segments.template.states.create("hover");
	hs.properties.strokeWidth = 5;
  }  // end for i


// -- Reducers (excluding the main)

  for (var i = 0; i < aux.preinfo[isel].n_reds; i++) {  // Reducers in a prediction
    var rname = aux.preinfo[isel].reducers[i];

    //if ( rname.indexOf(aux.preinfo[isel].main_reducer) == 0 )  // This is the main reducers: skip - no more
	//continue;

    if ( !p.reducers[rname].meta.use_in_plot )
	continue;

console.log('Create reducer:', rname);
 
    reducer = p.reducers[rname];
    var series = chart.series.push(new am4charts.LineSeries());
    series.dataFields.valueX = 'x';
    series.dataFields.valueY = rname;

    series.name = rname;
    series.strokeWidth = 2;

    if ( reducer.meta.color !== 'auto' ) {  // User selected color?
      series.stroke = reducer.meta.color;
      series.fill = reducer.meta.color;
    } else {
      // Skip colors used for components
      series.stroke = mycolors[(icol + i) % n_myc].hex;
      series.fill = mycolors[(icol + i) % n_myc].hex;
console.log('  color:', mycolors[(icol + i) % n_myc].name, mycolors[(icol + i) % n_myc].hex);
    }

    if ( !reducer.meta.default_visible )  // Reducer to hide?
      series.visible = false;

// Highlight when cursor on legend item
    hs = series.segments.template.states.create("hover");
    hs.properties.strokeWidth = 5;
  }  // end for i

}


//
// -- Select current prediction from multi-predictions list

function p_select(isel, new_file) {
  if ( isel === undefined )
	isel = 0;

  if ( new_file === undefined )
	new_file = false;

// First clear all series
  chart.series.each(function() {
	chart.series.removeIndex( 0 );
    //chart.series.removeIndex( chart.series.indexOf(s) );
  });

// Prediction selector buttons, if more than one
  if ( aux.n_p > 1 ) {
    document.getElementById('pred_'+ c_ipre).className = 'p_btn';
    document.getElementById('pred_'+ isel).className = 'p_btn p_btn-selected';
  }

  c_ipre = isel;  // Set index of selected prediction

  chart.data = mydata2chart(isel);
  createDataSeries();
  createCompSeries();

// Change plot labels
  document.getElementById('p_title').innerHTML = aux.preinfo[c_ipre].title;

// On new file read, fit log tables are created by createFitLogTabs
  if ( ! new_file )
	updatePredTabs(chart_data.predictions[c_ipre]);
}


//
// -- amChart code

am4core.ready(function() {

// Theme animated
  if ( am_anim )
	am4core.useTheme(am4themes_animated);

  chart = am4core.create('chartdiv', am4charts.XYChart);

// Disable logo ?
//chart.logo.disabled = true;

  if ( chart_data !== undefined ) {
    if (interface_type == 'fileio' )
	document.getElementById('myModal').className = 'modal modal-hide';

// Read metadata info
    getauxinfo();
    chart.data = mydata2chart(c_ipre); 

    document.getElementById('json_info').innerHTML = aux.n_spe +' data. Current: '+
	(aux.preinfo[0].n_comps) +'</strong> components fit.';

// Highlight button for current prediction
    if ( aux.n_p > 1 )
	document.getElementById('pred_'+ c_ipre).className = 'p_btn p_btn-selected';

  } else {
    for (var j = 0; j < 2 * Math.PI; j += 0.1)
	chart.data.push({"lambda": parseInt(1000 + j*1500), "y": Math.sin(j)});

// Open the file load div (if I/O mode interface)
    if ( interface_type == 'fileio' )
	openLoadDiv();
  }


// Create X axis

// Additional X axis as ValueAxis
  vxAxis = chart.xAxes.push(new am4charts.ValueAxis());
  vxAxis.dataFields.valueX = 'x';
  vxAxis.renderer.grid.template.stroke = am4core.color("#ddd");
  vxAxis.renderer.grid.template.strokeOpacity = 1;
  vxAxis.min = aux.preinfo[c_ipre].x_min;
  vxAxis.max = aux.preinfo[c_ipre].x_max;
  vxAxis.strictMinMax = true;  // This causes issue with the log plot

// No cursor Tooltip for ValueAxis
//vxAxis.cursorTooltipEnabled = true;
//vxAxis.precision = 4;

//vxAxis.renderer.grid.template.dx=5;
//vxAxis.renderer.labels.template.dx=5;
//--


// Create main Y-values axis
  valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
  valueAxis.title.fontSize = 18;
  valueAxis.renderer.grid.template.stroke = am4core.color("#ddd");
  valueAxis.renderer.grid.template.strokeOpacity = 1;

  valueAxis.strictMinMax = true;
//valueAxis.precision = 4;

// Eventually the second Y-value axis (for residuals). Note that it is only checked here!
  if ( typeof sdata.residuals !== undefined ) {  // TODO
    valueAxis2 = chart.yAxes.push(new am4charts.ValueAxis());
    valueAxis2.title.text = 'Residuals (\u03C3)';
    valueAxis2.renderer.opposite = true;
    valueAxis2.title.fontSize = 18;
    valueAxis2.renderer.grid.template.disabled = true;  // No grid

 
// Configure ticks
    valueAxis2.renderer.ticks.template.disabled = false;
    valueAxis2.renderer.ticks.template.strokeOpacity = 0;
    valueAxis2.renderer.ticks.template.stroke = am4core.color("#495C43");
    valueAxis2.renderer.ticks.template.strokeWidth = 2;
    valueAxis2.renderer.ticks.template.length = -10;  // Inward


// The +/- N sigma shaded region with the (dashed) 0 level. Visibility management is TODO.
    // 0 level dashed line
    range = valueAxis2.axisRanges.create();
    range.value = 0;
    range.grid.stroke = am4core.color("#396478");
    range.grid.strokeWidth = 2;
    range.grid.strokeDasharray = "4";

    // +/- N sigma shaded area with invisible strokes
    range2 = valueAxis2.axisRanges.create();
    range2.grid.stroke = am4core.color("#ff6478");
    range2.value = -n_sigma;
    range2.endValue = n_sigma;
    range2.grid.strokeOpacity = 0;
  }


// Cursor
  chart.cursor = new am4charts.XYCursor();
  chart.cursor.xAxis = vxAxis;
  chart.cursor.yAxis = valueAxis;
  chart.cursor.behavior = 'zoomXY';

// Scrollbar disabling labels and grid
  chart.scrollbarX = new am4charts.XYChartScrollbar();

// Increase contrast by taking every second color
  //chart.colors.step = 2;

// Monitor cursor position
  var cursorPosition = {
	x: null,
	y: null
  };
  chart.cursor.events.on("cursorpositionchanged", function(ev) {
	var xAxis = ev.target.chart.xAxes.getIndex(0);
	var yAxis = ev.target.chart.yAxes.getIndex(0);
	cursorPosition.x = xAxis.positionToValue(xAxis.toAxisPosition(ev.target.xPosition));
	cursorPosition.y = yAxis.positionToValue(yAxis.toAxisPosition(ev.target.yPosition));

	if ( cur_track )
		curXY.text = '[black]X:[/] '+ cursorPosition.x.toPrecision(6) +'\xa0\xa0\ [black]Y:[/] '+ cursorPosition.y.toPrecision(6);
  });

  chart.plotContainer.events.on("hit", function(ev) {
  console.log(cursorPosition);
	curXY.text = '[black]X:[/] '+ cursorPosition.x.toPrecision(6) +'\xa0\xa0\ [black]Y:[/] '+ cursorPosition.y.toPrecision(6);
  });

// Create container to hold cursor X, Y values
  cur_container = chart.plotContainer.createChild(am4core.Container);
  //cur_container.width = am4core.percent(50);
  cur_container.width = 240;
  cur_container.height = 36;
  cur_container.x = am4core.percent(50);
  cur_container.align = 'center';
  cur_container.y = 10;
  cur_container.padding(10, 10, 10, 10);
  cur_container.background.fill = am4core.color('#aaa');
  cur_container.background.fillOpacity = 0;

  curXY = cur_container.createChild(am4core.Label);
  curXY.id = 'cursor';
  curXY.text = '';
  curXY.minWidth = 50;
  curXY.align = 'center';
  curXY.marginRight = 6;
  curXY.fontWeight = 'bolder';
  curXY.fill = am4core.color('#396478');

// Monitor X axis zoom (TODO)
//vxAxis.events.on("startendchanged", vxAxisChanged);
//chart.scrollbarX.events.on("selectionextremeschanged", scrollAxisChanged);
  chart.scrollbarX.events.on("rangechanged", scrollAxisChanged);


// Does not work in log scale !

  function scrollAxisChanged(ev) {
        //var x_min = ev.target.minZoomed;
        //var x_max = ev.target.maxZoomed;
	var xaxis = chart.xAxes.getIndex(0);
	var x_min = xaxis.positionToValue(ev.target.range.start);
	var x_max = xaxis.positionToValue(ev.target.range.end);
console.log("New vxAxis range: " + x_min + " -- " + x_max);
	xyin_ranges.xmin.value = x_min.toPrecision(4);
	xyin_ranges.xmax.value = x_max.toPrecision(4);
	x_range.lin.min = x_min;
	x_range.lin.max = x_max;
	(x_min > 0) ? x_range.log.min = x_min : x_range.log.min = 1e-4;  // TODO
	x_range.log.max = x_max;
  }


// Need to manage manually the Y zoom (animation issue?)
  chart.cursor.events.on("zoomended", function(ev) {
	var xrange = ev.target.xRange;
	var xaxis = ev.target.chart.xAxes.getIndex(0);
	var x_min = xaxis.positionToValue(xrange.start);
	var x_max = xaxis.positionToValue(xrange.end);
console.log("X cursor selected from "+ x_min +" to "+ x_max);
	x_range.lin.min = x_min;
	x_range.lin.max = x_max;
	(x_min > 0) ? x_range.log.min = x_min : x_range.log.min = 1e-4;  // TODO
	x_range.log.max = x_max;

	var yrange = ev.target.yRange;
	var yaxis = ev.target.chart.yAxes.getIndex(0);
	//var y_min = yaxis.positionToValue(yaxis.toAxisPosition(yrange.start));
	//var y_max = yaxis.positionToValue(yaxis.toAxisPosition(yrange.end));
	var y_min = yaxis.positionToValue(yrange.start);
	var y_max = yaxis.positionToValue(yrange.end);
console.log("Y cursor selected from "+ y_min +" to "+ y_max);
	y_range.lin.min = y_min;
	y_range.lin.max = y_max;

	(y_min > 0) ? y_range.log.min = y_min : y_range.log.min = 1e-4;  // TODO
	y_range.log.max = y_max;

	xyin_ranges.xmin.value = x_min.toPrecision(4);
	xyin_ranges.xmax.value = x_max.toPrecision(4);
	xyin_ranges.ymin.value = y_min.toPrecision(4);
	xyin_ranges.ymax.value = y_max.toPrecision(4);

	if ( am_anim ) {
// If animation is on, a delay is necessary to have the Y zoom
	  setTimeout(function() {
		valueAxis.zoomToValues(y_min, y_max);
	  }, 100);
	}

  });


// Legends

  var legendContainer = am4core.create("res_legenddiv", am4core.Container);
  legendContainer.width = am4core.percent(100);
  //legendContainer.height = am4core.percent(100);

  legend2 = new am4charts.Legend();
  legend2.parent = legendContainer;
  legend2.marginTop = 20;
  legend2.marginLeft = 0;
  legend2.labels.template.text = "[bold]{name}[/]";
  legend2.useDefaultMarker = true;

  chart.legend = new am4charts.Legend();
  chart.legend.marginTop = 20;
  chart.legend.labels.template.text = "[bold]{name}[/]";
  chart.legend.useDefaultMarker = true;

  chart.legend.itemContainers.template.togglable = false;  // Disable default

  var marker = chart.legend.markers.template.children.getIndex(0);

  marker.cornerRadius(8, 8, 8, 8);
  marker.adapter.add("cornerRadiusTopLeft", radiusAdapter);
  marker.adapter.add("cornerRadiusTopRight", radiusAdapter);
  marker.adapter.add("cornerRadiusBottomLeft", radiusAdapter);
  marker.adapter.add("cornerRadiusBottomRight", radiusAdapter);

  chart.legend.itemContainers.template.adapter.add("tooltipText",  ttAdapter);
  chart.legend.tooltip.background.opacity = 0.7;
  chart.legend.tooltip.dy = -20;

  marker.width = 16;
  marker.height = 16;
  marker.strokeWidth = 2;
  marker.strokeOpacity = 1;
  marker.stroke = am4core.color("#ccc");

function radiusAdapter(radius, target) {
  if (!target.dataItem) {
    return radius;
  }

  if ( target.dataItem.name == 'uncert' )
	return 3;
  else
	return radius;
}

function ttAdapter(tooltip, target) {
  if ( target.dataItem.name == 'uncert' )
	return 'Show/hide data uncertainties shade area';
  else
	return '';
}


// Values background (unused)
  var lt = chart.legend.valueLabels.template;
  lt.background.fill = am4core.color("#efefef");
  lt.background.fillOpacity = 1;
  lt.minWidth = lt.width * 1.2;  // 20% increase. This fixes width change at run time

  chart.legend.itemContainers.template.events.on("over", function(event) {
    var segments = event.target.dataItem.dataContext.segments;
    segments.each(function(segment) {
      segment.isHover = true;
    });
  });

  chart.legend.itemContainers.template.events.on("out", function(event) {
    var segments = event.target.dataItem.dataContext.segments;
    segments.each(function(segment) {
      segment.isHover = false;
    });
  });


// Manage the click on the legend labels, in particular "residuals"
  chart.legend.itemContainers.template.events.on("hit", function(ev) {
    var field = ev.target.dataItem.dataContext,
	name = ev.target.dataItem.name,
	index = ev.target.dataItem.index;
console.log('Clicked:', name);
console.log('Index:', ev.target.dataItem.index);
console.log( 'visible', field.visible );

    if ( ! field.visible ) {
//field.show();
	field.visible = true;
	field.strokeOpacity = 1;
//chart.legend.markers.getIndex(index).fillOpacity = 1;
//chart.legend.labels.getIndex(index).fill = am4core.color("#333");
//ev.target.dataItem.marker.fillOpacity = 1;
//ev.target.dataItem.label.fill = am4core.color("#333");
    } else {
//field.hide();
	field.visible = false;
	field.strokeOpacity = 0;
//chart.legend.markers.getIndex(index).fillOpacity = 0.1;
//chart.legend.labels.getIndex(index).fill = am4core.color("#999");
//ev.target.dataItem.marker.fillOpacity = 0.1;
//ev.target.dataItem.label.fill = am4core.color("#999");
    }

  });


// Set up number format
//chart.numberFormatter.numberFormat = "#,###.000";

// The export menu
  chart.exporting.menu = new am4core.ExportMenu();

  chart.exporting.timeoutDelay = 5000;  // Wait 5 s before warning

// The series
  createDataSeries();
  createCompSeries();


// It seems this only works on first call (see set_x_range)
  //vxAxis.zoomToValues(aux.preinfo[c_ipre].x_min, aux.preinfo[c_ipre].x_max + aux.preinfo[c_ipre].x_step / 2);

// -- On data validation reset X / Y range for lin/log scale and clear input fields.
// -- Also disable scrollbar labels and grid. Need to be done after series push.

  chart.events.on('datavalidated', function(e) {

	var scrollAxis = chart.scrollbarX.scrollbarChart.xAxes.getIndex(0);
	scrollAxis.renderer.labels.template.disabled = true;
	scrollAxis.renderer.grid.template.disabled = true;

//document.getElementById('y_err-cb').checked = false;
//document.getElementById('y_err_shade-cb').checked = false;
	document.getElementById('cursor-cb').checked = false;
	document.getElementById('x_log-cb').checked = false;
	document.getElementById('y_log-cb').checked = false;
//errorBullet.hide();
//valueAxis.logarithmic = false;
//valueAxis.precision = 0;
	set_x_range();
	set_y_range();
	xy_rangein_reset();  // Clear manual range input fields

	createFitLogTabs();  // The fit log tables
  });

});  // end am4core.ready()


//
// -- Update residuals Nsigma shaded range and axis zoom

function n_sigma_update(e) {
  if ( ! resid.visible )
	return;

  n_sigma = +e.value;
  range2.value = -n_sigma;
  range2.endValue = n_sigma;

// Also zoom the axis range
  valueAxis2.zoomToValues(-n_sigma - 1, n_sigma + 1);
}


//
// -- The shaded error range area

function y_err_shade_toggle() {
  y_err_shade = document.getElementById('y_err_shade-cb').checked;

  if ( y_err_shade )
	serr.show();
  else
	serr.hide();
}


//
// -- Set initial X range

function set_x_range(from_rangein) {
// This is not set immediately and causes problems to the zoom below!
  var x_min, x_max;
  if ( from_rangein !== undefined && from_rangein == true ) {
	x_min = parseFloat(xyin_ranges.xmin.value !== '' ? xyin_ranges.xmin.value : vxAxis.min);
	x_max = parseFloat(xyin_ranges.xmax.value !== '' ? xyin_ranges.xmax.value : vxAxis.max);

	vxAxis.zoomToValues(x_min, x_max);
  } else {
	x_min = aux.preinfo[c_ipre].x_min;
	x_max = aux.preinfo[c_ipre].x_max;
	vxAxis.min = x_min;
	vxAxis.max = x_max;
  }

// For some reason here we need a value higher than xAxis.max to force alignement
//  vxAxis.zoomToValues(aux.preinfo[c_ipre].x_min, aux.preinfo[c_ipre].x_max + aux.preinfo[c_ipre].x_step / 2);

  x_range.lin.min = x_min;
  x_range.lin.max = x_max;
  (x_min > 0) ? x_range.log.min = x_min : x_range.log.min = 1e-4;  // TODO
  x_range.log.max = x_max;
}


//
// -- Set initial Y range

function set_y_range() {
  var y_min = aux.preinfo[c_ipre].y_min;
  var y_max = aux.preinfo[c_ipre].y_max;

// Then data, if exist
  if ( aux.n_d > 0 && chart_data.data[c_ipre] !== undefined ) {
	y_min = Math.min(y_min, Math.min(...(chart_data.data[c_ipre].y)));
	y_max = Math.max(y_max, Math.max(...(chart_data.data[c_ipre].y)));
  }

// All the other reducers
  for (var i = 0; i < aux.preinfo[c_ipre].n_reds; i++) {  // Reducers in a prediction
    var rname = aux.preinfo[c_ipre].reducers[i];

    //if ( rname.indexOf(aux.preinfo[c_ipre].main_reducer) == 0 )  // This is the main reducers: skip - no more
	//continue;

    y_min = Math.min(y_min, chart_data.predictions[c_ipre].reducers[rname].min);
    y_max = Math.max(y_max, chart_data.predictions[c_ipre].reducers[rname].max);
  }

console.log('Y range set to:', y_min, y_max);
  y_range.lin.min = y_min;
  y_range.lin.max = y_max;
  (y_min > 0) ? y_range.log.min = y_min : y_range.log.min = 1e-4;  // TODO
  y_range.log.max = y_max;

// Needed at start
  valueAxis.min = y_range.lin.min;
  valueAxis.max = y_range.lin.max;
  setTimeout(function() {
	y_linlog_toggle();
  }, 300);
}


//
// -- Toggle Y data error plot (unused)
/*
function y_err_toggle() {
  y_errplot = document.getElementById('y_err-cb').checked;

  if ( y_errplot )
	errorBullet.show();
  else
	errorBullet.hide();

}
*/


// -- Track and display cursor X, Y position 

function cursor_toggle() {
  cur_track = document.getElementById('cursor-cb').checked;
  curXY.text = '';

  if ( cur_track )
	cur_container.background.fillOpacity = 0.1;
  else
	cur_container.background.fillOpacity = 0;

}


//
// -- Toggle linear / logarithmic X / Y scale

function x_linlog_toggle() {
  x_logscale = document.getElementById('x_log-cb').checked;

  if ( x_logscale ) {   // From lin to log
//vxAxis.min = x_range.log.min;
//vxAxis.max = x_range.log.max;
	vxAxis.logarithmic = true;
	if ( x_range.log.max == x_range.lin.max )
	  x_range.log.max *= 1.001;
	vxAxis.zoomToValues(x_range.log.min, x_range.log.max);
  } else {  // From log to lin
//vxAxis.min = x_range.lin.min;
//vxAxis.max = x_range.lin.max;
	vxAxis.logarithmic = false;
	if ( x_range.log.max == x_range.lin.max )
	  x_range.lin.max *= 1.001;
	vxAxis.zoomToValues(x_range.lin.min, x_range.lin.max);
  }

}


function y_linlog_toggle() {
  y_logscale = document.getElementById('y_log-cb').checked;
  var c_ymax;

  if ( y_logscale ) {  // From lin to log
	valueAxis.min = y_range.log.min;
	valueAxis.logarithmic = true;
	//valueAxis.strictMinMax = true;
	c_ymax = y_range.log.max;
	if ( c_ymax == valueAxis.maxZoomed )
	  c_ymax *= 1.001;
	valueAxis.max = c_ymax;
	setTimeout(function() {
	  valueAxis.zoomToValues(y_range.log.min, c_ymax);
	}, 200);
  } else {  // From log to lin
	valueAxis.min = y_range.lin.min;
	valueAxis.logarithmic = false;
	c_ymax = y_range.lin.max;
	if ( c_ymax == valueAxis.maxZoomed )
	  c_ymax *= 1.001;
	valueAxis.max = c_ymax;
	valueAxis.zoomToValues(y_range.lin.min, c_ymax);
  }
}


//
// -- Set X and Y plot range to fixed ranges

function xy_range_set() {
// Note: need to parse to Float
// It also wants "0.nnn" and not ".nnn"
  var x_size = vxAxis.max - vxAxis.min;
  if ( x_size <= 0 )
	x_size = aux.preinfo[c_ipre].x_step;

  var vx_min = parseFloat(xyin_ranges.xmin.value !== '' ? xyin_ranges.xmin.value : vxAxis.min);
  var vx_max = parseFloat(xyin_ranges.xmax.value !== '' ? xyin_ranges.xmax.value : vxAxis.max);

  var y_min = xyin_ranges.ymin.value !== '' ? parseFloat(xyin_ranges.ymin.value) : valueAxis.min;
  var y_max = xyin_ranges.ymax.value !== '' ? parseFloat(xyin_ranges.ymax.value) : valueAxis.max;

// Some checks
  if ( vx_min > vx_max ) {
	var tmp = vx_max;
	vx_max = vx_min;
	vx_min = tmp;
  } else if ( vx_min == vx_max )
	vx_max = vx_min + aux.preinfo[c_ipre].x_step; 

  if ( y_min > y_max ) {
        var tmp = y_max;
        y_max = y_min;
        y_min = tmp;
  } else if ( y_min == y_max )
        return false;

  if ( y_min != valueAxis.min || y_max != valueAxis.max ) {
	valueAxis.strictMinMax = true;
	if ( y_min != valueAxis.min )
	  valueAxis.min = y_min;

	if ( y_max != valueAxis.max )
	  valueAxis.max = y_max;
  }


  if ( vx_min != vxAxis.min || vx_max != vxAxis.max )
	vxAxis.zoomToValues(vx_min, vx_max);

// A delay is necessary to have the Y zoom
  setTimeout(function() {
	valueAxis.zoomToValues(y_min, y_max);
  }, 600);

}


// -- Reset X and Y plot range to initial values

function xy_range_reset() {
  set_x_range();
  set_y_range();
  xy_rangein_reset();  // Clear manual range input fields
console.log('reset X, Y range:', vxAxis.min, vxAxis.max, valueAxis.min, valueAxis.max);
  vxAxis.zoomToValues(vxAxis.min, vxAxis.max);
  valueAxis.zoomToValues(valueAxis.min, valueAxis.max);

  curXY.text = '';
}


// -- Clear range input fields

function xy_rangein_reset() {
  xyin_ranges.xmin.value = '';
  xyin_ranges.xmax.value = '';
  xyin_ranges.ymin.value = '';
  xyin_ranges.ymax.value = '';
}


//
// -- Show/hide the fit log tables

function fitlog_toggle() {
  var e = document.getElementById('fitlog_div');
  if ( ! isHidden(e) ) {
    e.className = 'div-hide';
    document.getElementById('fitlog_sect').className = 'toggle_table-hdr';
    document.getElementById('view_fitlog_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'rep_div-show';
    document.getElementById('fitlog_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_fitlog_angle').className = 'fas fa-angle-up ud-angle';
  }
}


//
// -- Show/hide the components / predictions / reducers log tables

function comp_table_toggle() {
  var e = document.getElementById('comp_table-div');
  if ( ! isHidden(e) ) {
    e.className = 'out_table div-hide';
    document.getElementById('comp_table_sect').className = 'toggle_table-hdr';
    document.getElementById('view_comp_table_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'out_table rep_div-show';
    document.getElementById('comp_table_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_comp_table_angle').className = 'fas fa-angle-up ud-angle';
  }
}

function pred_table_toggle() {
  var e = document.getElementById('pred_table-div');
  if ( ! isHidden(e) ) {
    e.className = 'out_table div-hide';
    document.getElementById('pred_table_sect').className = 'toggle_table-hdr';
    document.getElementById('view_pred_table_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'out_table rep_div-show';
    document.getElementById('pred_table_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_pred_table_angle').className = 'fas fa-angle-up ud-angle';
  }
}

function fitres_table_toggle() {
  var e = document.getElementById('fitres_table-div');
  if ( ! isHidden(e) ) {
    e.className = 'out_table div-hide';
    document.getElementById('fitres_table_sect').className = 'toggle_table-hdr';
    document.getElementById('view_fitres_table_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'out_table rep_div-show';
    document.getElementById('fitres_table_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_fitres_table_angle').className = 'fas fa-angle-up ud-angle';
  }
}


//
// -- Download the full original JSON data

function savejsonobj(filename, obj) {
  var a = document.createElement('a');
  var file = new Blob([JSON.stringify(obj)], {type: 'text/plain'});

  a.href = URL.createObjectURL(file);
  a.setAttribute('download', filename);
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}


//
// -- Display input JSON formatted fit results in table format
// -- Params:
//    obj: the json object
//    type: 0=components, 1=prediction, 2=reducer, 3=fit_results
//    tab_id: the (html) id to give to the created table

var tableFromJson = function(obj, type, tab_id) {
  var col = [], tlab = document.createElement('div'),
	contentdiv, tabdiv, tab, tb, hdr, tr, tabCell, comp, cname, nc, ncol, title;

// Define component/prediction/reducer reference object and header from type
  switch (type) {
    case 0:
	comp = obj.components;

	title = '<i id="view_comp_table_angle" class="fas fa-angle-down ud-angle"></i>Components'
	tlab.setAttribute('id', 'comp_table_sect');
	tlab.setAttribute('class', 'toggle_table-hdr');
	tlab.setAttribute('onclick', 'comp_table_toggle()');
	col = ['Component', 'Type', 'Param.', 'Value', 'Range'];	
	break;
    case 1:
	comp = obj.compevals;

	title = '<i id="view_pred_table_angle" class="fas fa-angle-down ud-angle"></i>Prediction'
	tlab.setAttribute('id', 'pred_table_sect');
	tlab.setAttribute('class', 'toggle_table-hdr');
	tlab.setAttribute('onclick', 'pred_table_toggle()');
	col = ['Component', 'Counter', 'Min', 'Max', 'Mean', 'NaN/Inf'];	
	break;
    case 2:
	comp = obj.reducers;

	title = 'Reducer';
	tlab.setAttribute('class', 'header-lab');
	col = ['Component', 'Counter', 'Min', 'Max', 'Mean', 'NaN/Inf'];	
	break;
    case 3:
	comp = obj.predictions[0].components;

	title = '<i id="view_fitres_table_angle" class="fas fa-angle-down ud-angle"></i>Best Fit results'
	tlab.setAttribute('id', 'fitres_table_sect');
	tlab.setAttribute('class', 'toggle_table-hdr');
	tlab.setAttribute('onclick', 'fitres_table_toggle()');
	col = ['Component', 'Param.', 'Value', 'Uncert.', 'Fixed', 'Patched'];	
	break;

    default:
	console.log(`Sorry, option not recognised: ${type}.`);
  }

  cname = Object.keys(comp);  // comp. names
  nc = cname.length;

  tlab.innerHTML = title;
  ncol = col.length;

// Create a table with its id

  tabdiv = document.createElement('div');
  tabdiv.appendChild(tlab);

  contentdiv = document.createElement('div');
  tabdiv.appendChild(contentdiv);

  if ( tab_id !== undefined )
	contentdiv.setAttribute('id', tab_id);
  if ( type == 0 || type == 1 )  // Components / prediction + reducer hidden by default
	contentdiv.setAttribute('class', 'div-hide');

  tab = document.createElement('table');
  contentdiv.appendChild(tab);

// Create table header row using the extracted headers above
  hdr = tab.createTHead();
  tr = hdr.insertRow(0);

  for (var i = 0; i < col.length; i++) {
	var th = document.createElement('th');
	th.innerHTML = col[i];
	tr.appendChild(th);
  }

// Table body 
  tb = tab.appendChild(document.createElement('tbody'));

// Add json data to the table as rows
  switch (type) {
    case 0:  // components
	for (var i = 0; i < nc; i++) {
	  var c = comp[cname[i]],  // comp. obj.
		par_tt = '',  // Parameter tooltip
		pname = Object.keys(c.params);  // par. names

	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = c.type;	 // 2nd column is comp. type

	  var cell = pname[0];  // 3rd column is par. names
	  par_tt = '<strong>'+ cname[i] +'</strong><br />'+ pname[0] +' (unit: '+ c.params[pname[0]].meta.unit +' note: '+ c.params[pname[0]].meta.note +')';

	  if ( c.params[pname[0]].fixed == true )
		cell += ' (FIXED)';
	  for (var k = 1; k < pname.length; k++) {
	    cell += '<br />'+ pname[k];
	    if ( c.params[pname[k]].fixed == true )
		cell += ' (FIXED)';
	    par_tt += '<br />'+ pname[k] +' (unit: '+ c.params[pname[k]].meta.unit +' note: '+ c.params[pname[k]].meta.note +')';
	  }


// Add cell with tooltip text.
	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = '<div class="partip"><span class="partiptext">'+ par_tt +'</span>'+
			cell + '</div>';
//tabCell.title = par_tt;

	  cell = '';
	  var v = c.params[pname[0]].value;  // 4th is par. values
	  if ( typeof v == 'number')
		v = +v.toPrecision(4);

	  cell = v;
	  for (var k = 1; k < pname.length; k++) {
		v = c.params[pname[k]].value;
		if ( typeof v == 'number')
		  v = +v.toPrecision(4);
		cell += '<br />'+ v;
	  }
	  tabCell = tr.insertCell(-1);
	  tabCell.classList.add('al-right');
	  tabCell.innerHTML = cell;
//tabCell.title = par_tt;

	  if ( c.params[pname[0]].low === null && c.params[pname[0]].high === null )  // 5th is par. range
		cell = ''
	  else
		cell = pRange(c.params[pname[0]].low, c.params[pname[0]].high, 4);

	  for (var k = 1; k < pname.length; k++) {
		if ( c.params[pname[k]].low === null && c.params[pname[k]].high === null )
			v = ''
		else
			v = pRange(c.params[pname[k]].low, c.params[pname[k]].high, 4);
		cell += '<br />'+ v;
	  }
	  tabCell = tr.insertCell(-1);
	  tabCell.classList.add('al-right');
	  tabCell.innerHTML = cell;

	}  // end for i
	break;

    case 1:  // predictions
	var c, cell, pcol = ['counter', 'min', 'max', 'mean', 'error'];

	for (var i = 0; i < nc; i++) {
	  c = comp[cname[i]];  // comp. obj
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )  // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
		if ( [pcol[j]] == 'error' )
			cell = '<span style="background: var(--danger); color: #fff; padding-left: 5px;">'+ cell +'</span>';
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}  // end for i
	break;

    case 2:  // reducers
	var c, cell, pcol = ['counter', 'min', 'max', 'mean', 'error'];

	for (var i = 0; i < nc; i++) {
	  c = comp[cname[i]];  // comp. obj
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )  // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}  // end for i
	break;

    case 3:  // best fit results
	for (var i = 0; i < nc; i++) {
	  var c = comp[cname[i]];  // comp. obj.
	  var pname = Object.keys(c);  // par. names
	  var pkname = [];  // par. key value names

	  for (var key in c[pname[0]])  // Keys from first parameter
		pkname.push(key);
//console.log('pkname:',pkname);
 
	  var np_fit = 0;  // Fit params counter

	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // First column is comp. name

	  var cell = pname[0];  // Second column is par. name

	  for (var k = 1; k < pname.length; k++) {
	    cell += '<br />'+ pname[k];
	  }

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cell;

	  for (var j = 0; j < ncol - 2; j++) {  // Third+ columns are par. values
	    var cell = '';
	    var v = c[pname[0]][pkname[j]];
	    if ( typeof v == 'number') {
		v = +v.toPrecision(4);
		np_fit++;
		if ( pkname[j] == 'patched' && v !== +c[pname[0]]['val'].toPrecision(4) )
			v = '<span style="background: var(--danger); color: #fff;  padding-left: 5px;">'+ v +'</span>';
	    } else if ( pkname[j] == 'unc' ) {  // null
			v = '';
	    } else if ( pkname[j] == 'fixed' ) {
		if ( v )
			v = 'fixed';
		else
			v = '';
	    }
	    cell = v;
	    for (var k = 1; k < pname.length; k++) {
		v = c[pname[k]][pkname[j]];
		if ( typeof v == 'number') {
		  v = +v.toPrecision(4);
		  np_fit++;
		  if ( pkname[j] == 'patched' && v !== +c[pname[k]]['val'].toPrecision(4) )
			v = '<span style="background: var(--danger); color: #fff;  padding-left: 5px;">'+ v +'</span>';
		} else if ( pkname[j] == 'unc' ) {  // null
			v = '';
		} else if ( pkname[j] == 'fixed' ) {
		  if ( v )
			v = 'fixed';
		  else
			v = '';
		}
		cell += '<br />'+ v;
	    }
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }
	}

	// The summary table
	var summdiv = document.createElement('div');
	summdiv.setAttribute('class', 'summ-div');

	var div = document.createElement('div');
	div.setAttribute('class', 'summ-div-col');
	div.innerHTML = '<ul><li><div class="fres-fixw">#Data</div>'+ ':<div class="fres-int">'+ obj.ndata +'</div></li>'+
 	'<li><div class="fres-fixw">#Param</div>'+':<div class="fres-int">'+ np_fit +'</div></li>'+
	'<li><div class="fres-fixw">DOF</div>'+':<div class="fres-int">'+ obj.dof +'</div></li>'+
	'<li><div class="fres-fixw">#Param</div>'+':<div class="fres-int" style="color: '+ (obj.status == 'OK' ? 'var(--success);"' : 'var(--danger);') +'">'+ obj.status +'</div></li></ul>';

	summdiv.appendChild(div);

	div = document.createElement('div');
	div.setAttribute('class', 'summ-div-col');
	div.innerHTML = '<ul><li><div class="fres-fixw">Cost</div>'+ ':<div class="fres-float">'+ obj.cost.toPrecision(4) +'</div></li>'+
	'<li><div class="fres-fixw" style="line-height: 1.3rem;">&chi;<sup>2</sup><sub>red</sub></div>'+':<div class="fres-float">'+ (obj.cost / obj.dof).toPrecision(4) +'</div></li>'+
	'<li><div class="fres-fixw">Prob.</div>'+':<div class="fres-float">'+ Math.pow(10, obj.log10testprob).toPrecision(4) +'</div></li>'+
	'<li><div class="fres-fixw">Elapsed</div>'+':<div class="fres-float">'+ obj.elapsed.toPrecision(4) +'</div> s</li></ul>';

	summdiv.appendChild(div);

	tabdiv.appendChild(summdiv);

	break;

    default:
	console.log(`Sorry, option not recognised: ${type}.`);
  }

  return tabdiv;
}


//
// -- Update the prediction+reducer tables with current data

function updatePredTabs(obj) {
  var comp = obj.compevals,
	cname = Object.keys(comp),  // comp. names
	nc = cname.length,
	red = obj.reducers,
	rname = Object.keys(red),  // red. names
	nr = rname.length,

	tab = document.getElementById('pred_table-div'),  // predictions
	tb = tab.getElementsByTagName("tbody")[0],
	pcol = ['counter', 'min', 'max', 'mean', 'error'],
	c, cell, tr, tabCell;

	tb.innerHTML = '';

	for (var i = 0; i < nc; i++) {
	  c = comp[cname[i]];  // comp. obj.
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )   // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}

	tab = document.getElementById('red_table-div');  // reducers
	tb = tab.getElementsByTagName("tbody")[0];
	tb.innerHTML = '';

	for (var i = 0; i < nr; i++) {
	  c = red[rname[i]];  // comp. obj.
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = rname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )   // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}
}


//
// -- The fit log tables sections

function createFitLogTabs() {
  var divShowData = document.getElementById('fitlog_tab');
  divShowData.innerHTML = '';

  tabdiv = tableFromJson(chart_data.predictions[c_ipre], 0, 'comp_table-div');
  divShowData.appendChild(tabdiv);  // Add the components table to the container

// Current prediction/reducer tables
  tabdiv = tableFromJson(chart_data.predictions[c_ipre], 1, 'pred_table-div');
  divShowData.appendChild(tabdiv);  // Add the prediction table to the container

// Add the reducer table to the prediction container
  tabdiv = tableFromJson(chart_data.predictions[c_ipre], 2, 'red_table-div');
  document.getElementById('pred_table-div').appendChild(tabdiv);

  if ( chart_data.bestfit !== undefined && chart_data.bestfit !== null ) {
    tabdiv = tableFromJson(chart_data.bestfit, 3, 'fitres_table-div');
    divShowData.appendChild(tabdiv);  // Add the fit_res table to the container
  }
}
</script>

</div>

<div class="trailer"></div>

</body>
</html>
