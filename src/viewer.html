<!DOCTYPE html>
<html>
<head>
  <title>The personal GFit viewer</title>
  <meta http-equiv=Content-Type content="text/html; charset=UTF-8" />
  <meta http-equiv=Content-Script-Type content="text/javascript" />
  <meta http-equiv=Content-Style-Type content="text/css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="GFitViewer - web viewer for the GFit produced results" />
  <meta name="generator" content="vi+LN" />
  <meta name="author" content="Luciano Nicastro, INAF" />
  <meta name="publisher" content="INAF" />
  <meta name="language" content="en" />
  <meta name="version" content="0.1d" />
  <meta name="date" content="2020-11-12" />

<!-- @Remote
-->
  <link href="https://qsfit.inaf.it/images/qsfit_logo.ico.gif" rel="shortcut icon" type="image/x-icon" />

  <script src="https://www.amcharts.com/lib/4/core.js"></script>
  <script src="https://www.amcharts.com/lib/4/charts.js"></script>
  <script src="https://www.amcharts.com/lib/4/themes/animated.js"></script>
  <link href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" type="text/css" rel="stylesheet" crossorigin="anonymous" />

  <link href="https://qsfit.inaf.it/GFitViewer/local/gfitviewer.css" type="text/css" rel="stylesheet" />

<!-- @Local
  <link href="./local/qsfit_logo.ico.gif" rel="shortcut icon" type="image/x-icon" />

  <script src="./local/amcharts_core.js"></script>
  <script src="./local/amcharts_charts.js"></script>
  <script src="./local/amcharts_animated.js"></script>
  <link href="./local/fontawesome/css/fontawesome.css" rel="stylesheet">
  <link href="./local/fontawesome/css/solid.css" rel="stylesheet">

  <link href="./local/gfitviewer.css" type="text/css" rel="stylesheet" />
-->
</head>

<body>

<div class="hdrdiv2">
  <div style="line-height: 48px;">
    <span style="vertical-align: middle; font-size: larger">GFitViewer</span>
&minus;
    <span style="font-size: 1rem; font-style: italic; color: #ccc; vertical-align: middle;">Version 0.1a</span>
  </div>
</div>


<section class="page_top_tbar">

<div>
  <button class="submit_grey" type="submit" onclick="openLoadDiv()" id="myBtn"><i class="fas fa-file-import"></i>Load file</button>

  <div style="display: inline-block; padding-left: 0.5rem;">
    <div>
      <span id="json_info" style="font-weight: bold;">Data file info...</span> <span id="spe_size"></span>
      <button id="viewbutton" class="simple_button" style="padding-right: 0.2rem;" onclick="savejsonobj('gfit_data.json', chart_data)">
        <i class="fas fa-download" aria-hidden="true"></i>Save JSON data</button>
	<div class="spe_sel-div">
		Select prediction # <span id="p_selector"></span>
	</div>
    </div>
  </div>
</div>

</section>


<div class="interface">

  <div id="myModal" class="modal">
<!-- Modal content -->
    <div id="myModal_cont" class="modal-content">

	    <div class="modal-header">
        <span class="close" title="Close">&times;</span>
        <h3 class="modal-header-text">GFitViewer file selector ...</h3>
	    </div>

	    <div id="modal-logdiv" class="modal-body">

	      <div id="dropzone">
		    <div>
		      Drag &amp; drop a GFitViewer file here...
		      <br />or<br />
		      <label for="selfile" class="custom-file-select"><i class="fas fa-search" style="padding-right: .5rem;"></i>Browse ...</label>
		      <input id="selfile" type="file" accept=".json" />
		    </div>
	      </div>

	      <progress value="0" max="100" id="progress-bar"></progress>
	      <div id="status" style="display: inline-block;"></div>
	    </div>

    </div>
  </div>

  <p>
	<span id="p_title">GFitViewer info here...</span> <span id="spe_size"></span>

	<span class="box-in" style="float: right;" title="Set the highlighted resid. range">Resid. &pm; N&sigma;
	<input type="number" style="width: 2rem;" min="1" max="10" step="1" name="n_sigma" id="n_sigma" value="3" onchange="n_sigma_upd(this)" />
	</span>
  </p>


  <div id="chartdiv"></div>

  <div id="controls-div">
	<span class="box-cb" title="Toggle Y lin/log scale">
	  <input type="checkbox" id="y_log-cb" onclick="y_linlog_toggle()" /><label for="y_log-cb">Y log</label>
	</span>

	<div id="range-selector-div">
	<span class="label-range-in">X<sub>min</sub> </span><input name="xmin" type="text" class="range-in" value="" onchange="xy_range_set()" />
	<span class="label-range-in">X<sub>max</sub> </span><input name="xmax" type="text" class="range-in" value="" onchange="xy_range_set()" />
	<span class="label-range-in" style="margin-left: 1em;">Y<sub>min</sub> </span><input name="ymin" type="text" class="range-in" value="" onchange="xy_range_set()" />
	<span class="label-range-in">Y<sub>max</sub> </span><input name="ymax" type="text" class="range-in" value="" onchange="xy_range_set()" />

	<button class="transp_button" style="color: var(--success); padding: 7px 2px;" title="Replot with these ranges (2nd click to force Y range)" onclick="xy_range_set()">
        <i class="far fa-check-circle" aria-hidden="true"></i>
	</button>
<!--
	<button class="transp_button" style="color: #1177d1;" title="Reset ranges" onclick="xy_range_reset()">
        <i class="fas fa-times" aria-hidden="true"></i>
	</button>
-->
	<button class="transp_button" style="color: var(--danger);" title="Clear input" onclick="xy_rangein_reset()">
        <i class="fas fa-times" aria-hidden="true"></i>
	</button>
	</div>

  </div>

<hr class="style-one"></hr>


  <script>
    var chart_data = JSON_DATA;
  </script>

<script type="text/javascript">

// Initialize metadata and local variables
  const def_lum_units_s = 42,   // Luminosity units exponent
	def_flx_units_s = -17,  // Flux units exponent
	def_lum_scale = 1;      // Luminosity scale factor wrt 1e42

  var c_ipre = 0,	// Currently plotted prediction index
	n_sigma = 3,	// Highlight residuals region within this +/- sigma
	y_logscale = false,  // Y lin/log scale
	y_range = {lin: [null, null], log: [null, null]},  // lin/log Y ranges
	chart = {},	// The amchart object
	sdata = [],	// The data series to plot (with errors)
	resid = [],	// The residuals
	aux = {},	// The metadata information read from the json file and more,
	valueAxis2,	// The residuals right axis object
	range, range2,	// Used to highlight +/- N sigma residuals. (TODO)
	xAxis, valueAxis;


// A set of 18 colors + white + black (grey, blue and darkblue removed and used by def. for the data, main reducer and residuals array)
  var mycolors = [
        {'name':'Red', 'hex':'#e6194b', 'rgb':'(230, 25, 75)', 'rgba':'(230, 25, 75, 0.5)'},
        {'name':'Green', 'hex':'#3cb44b', 'rgb':'(60, 180, 75)', 'rgba':'(60, 180, 75, 0.5)'},
        {'name':'Yellow', 'hex':'#ff7518', 'rgb':'(255, 117, 24)', 'rgba':'(255, 117, 24, 0.5)'},
        {'name':'Orange', 'hex':'#f0ad4e', 'rgb':'(240, 173, 78)', 'rgba':'(240, 143, 78, 0.5)'},
        {'name':'Purple', 'hex':'#911eb4', 'rgb':'(145, 30, 180)', 'rgba':'(145, 30, 180, 0.5)'},
        {'name':'Cyan', 'hex':'#46f0f0', 'rgb':'(70, 240, 240)', 'rgba':'(70, 240, 240, 0.5)'},
        {'name':'Magenta', 'hex':'#f032e6', 'rgb':'(240, 50, 230)', 'rgba':'(240, 50, 230, 0.5)'},
        {'name':'Lime', 'hex':'#d2f53c', 'rgb':'(210, 245, 60)', 'rgba':'(210, 245, 60, 0.5)'},
        {'name':'Pink', 'hex':'#fabebe', 'rgb':'(250, 190, 190)', 'rgba':'(250, 190, 190, 0.5)'},
        {'name':'Teal', 'hex':'#008080', 'rgb':'(0, 128, 128)', 'rgba':'(0, 128, 128, 0.5)'},
        {'name':'Lavender', 'hex':'#e6beff', 'rgb':'(230, 190, 255)', 'rgba':'(230, 190, 255, 0.5)'},
        {'name':'Brown', 'hex':'#aa6e28', 'rgb':'(170, 110, 40)', 'rgba':'(170, 110, 40, 0.5)'},
        {'name':'Beige', 'hex':'#fffac8', 'rgb':'(255, 250, 200)', 'rgba':'(255, 250, 200, 0.5)'},
        {'name':'Maroon', 'hex':'#800000', 'rgb':'(128, 0, 0)', 'rgba':'(128, 0, 0, 0.5)'},
        {'name':'Mint', 'hex':'#aaffc3', 'rgb':'(170, 255, 195)', 'rgba':'(170, 255, 195, 0.5)'},
        {'name':'Olive', 'hex':'#808000', 'rgb':'(128, 128, 0)', 'rgba':'(128, 128, 0, 0.5)'},
        {'name':'Coral', 'hex':'#ffd8b1', 'rgb':'(255, 215, 180)', 'rgba':'(255, 215, 180, 0.5)'},
        {'name':'Navy', 'hex':'#000080', 'rgb':'(0, 0, 128)', 'rgba':'(0, 0, 128, 0.5)'},
        {'name':'White', 'hex':'#FFFFFF', 'rgb':'(255, 255, 255)', 'rgba':'(255, 255, 255, 0.5)'},
        {'name':'Black', 'hex':'#000000', 'rgb':'(0, 0, 0)', 'rgba':'(0, 0, 0, 0.5)'}
  ], n_myc = 18,

// Data color
  dcolor = {'name':'Grey', 'hex':'#808080', 'rgb':'(128,128,128)', 'rgba':'(128,128,128, 0.5)'},

// Main reducer color
  mcolor = {'name':'Blue', 'hex':'#0082c8', 'rgb':'(0, 130, 200)', 'rgba':'(0, 130, 200, 0.5)'},

// Residuals color
  rcolor = {'name':'Darkblue', 'hex':'#386cb0', 'rgb':'(56,108,176)', 'rgba':'(56,108,176, 0.5)'};


// Format numbers > 1000 adding the "," separator

const numberWithCommas = (x) => {
  return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


// Compute the number of fractional "significant" digits in sequential values from the given (~constant) step

const nfSignificant = (x) => {
  return Math.max((Math.abs(x) % 1).toPrecision(1).length - 2, 0);
}

// Format the parameters range at a given digits precision

pRange = function(low, high, np) {
  if ( low === null && high === null )
    return '';

  if ( np === undefined )
    np = 4;

  if ( low === undefined || typeof low !== 'number' )
    v = '-Inf';
  else {
    v = low;
    if ( ! Number.isInteger(v) )
	v = +v.toPrecision(np);  // To number to remove trailing 0s
  }
  if ( high === undefined || typeof high !== 'number' )
    v += ':Inf';
  else {
    var v2 = high;
    if ( ! Number.isInteger(v2) )
	v2 = +v2.toPrecision(np);
    v += ':'+ v2;
  }
  return v;
}


// Hidden object?

function isHidden(e) {
	return (e.offsetParent === null)
}


// -- Open the file load modal div

function openLoadDiv() {
// Get the button that opens the modal
  //var btn = document.getElementById("myBtn");

// When the user clicks the button, open the modal 
  showLoadDiv();

// Clean progress bar and load status message
  document.getElementById('progress-bar').value = 0;
  changeStatus('');

// Get the <span> element that hides the modal
  var span = document.getElementsByClassName('close')[0];

// When the user clicks on <span> (x), hide the modal
  span.onclick = function() {
	hideLoadDiv();
  }

// When the user clicks anywhere outside of the modal, hide it
  window.onclick = function(event) {
    var modal = document.getElementById('myModal');
    if ( event.target == modal )
	hideLoadDiv();
  }
}


// -- Show the modal div

function showLoadDiv() {
  var modal = document.getElementById('myModal');
  modal.className = 'modal modal-slidein';
}


// -- Hide the modal div

function hideLoadDiv() {
  var modal = document.getElementById('myModal');
  modal.className = 'modal modal-slideout';
}


//
// -- Files drop management

window.onload = function() {
	var dropzone = document.getElementById("dropzone");
	dropzone.ondragover = dropzone.ondragenter = function(event) {
		event.stopPropagation();
		event.preventDefault();
	}

	dropzone.ondrop = function(event) {
		event.stopPropagation();
		event.preventDefault();

		var filesArray = event.dataTransfer.files;
		for (i = 0; i < filesArray.length; i++)  // Actually here should limit to 1 file!
			processFile(filesArray[i]);
	}
}


//
// -- Files loading listening to "selfile" element change

document.getElementById('selfile').addEventListener('change', (e) => {
	const file = document.getElementById('selfile').files[0];
	if ( file )
	  processFile(file);
});


// A basic error handler for FileReader

const errorHandler = (e) => {
	changeStatus("Error: "+ e.target.error.name);
}


// Updates the value of the progress bar

const setProgress = (e) => {
// The target is the file reader
	const fr = e.target;
	const loadingPercentage = 100 * e.loaded / e.total;
	document.getElementById('progress-bar').value = loadingPercentage;
}

const changeStatus = (status) => {
	document.getElementById('status').innerHTML = status;
}


// Manage local file upload

const processFile = (file) => {
	const fr = new FileReader();
	fr.readAsText(file);
	fr.onprogress = setProgress;
	fr.onerror = errorHandler;
	fr.onabort = () => changeStatus('Start Loading');
	fr.onloadstart = () => changeStatus('Start Loading');
	fr.onload = loadedok;
	fr.onloadend = () => fileInfo(file);

// At this point we can also perform some operations on the data asynchronously
}


// Display file info in the interface, considering data origin (local or web)

const fileInfo = (file) => {
	document.getElementById('progress-bar').value = 100;
	changeStatus('Loaded!');
	var fname, size_info = 'Loaded <strong>';
	if ( typeof file === 'object' ) {
		document.getElementById('json_info').innerHTML = file.name;
		size_info += numberWithCommas(chart.data.length) +'</strong> elements, <strong>'+ numberWithCommas(file.size) +'</strong> bytes';
	} else if ( typeof file === 'string' ) {
		document.getElementById('json_info').innerHTML = file.split('/').reverse()[0];
		size_info = numberWithCommas(chart.dataSource.data.length) +'</strong> elements array';
	}
	document.getElementById('spe_size').innerHTML = size_info;
}


// Loading completed successfully; pass the data to chart

const loadedok = (e) => {
	const fr = e.target;
	chart_data = JSON.parse(fr.result);
	getauxinfo();

	p_select(0);
	hideLoadDiv();
}


//
// -- Create all the component series

function createAllCompSeries() {  // Unused!
  var p = chart_data.predictions[c_ipre], hs;

  for (var i = 0; i < aux.preinfo[c_ipre].n_comps; i++) {
    var cname =  aux.preinfo[c_ipre].components[i];
    var component = p.components[cname];

    if ( !component.meta.use_in_plot )  // Component has data?
	continue;

    var series = chart.series.push(new am4charts.LineSeries());

    series.dataFields.categoryX = 'x';
    series.dataFields.valueY = cname;

    series.name = cname;
    series.strokeWidth = 2;
    series.legendSettings.valueText = "{valueY}";

// User selected color?
    if ( component.meta.color !== 'auto' ) {
      series.stroke = component.meta.color;
      series.fill = component.meta.color;
    } else {
      series.stroke = mycolors[i % n_myc].hex;
      series.fill = mycolors[i].hex;
    }

// Component to hide?
    if ( !component.meta.default_visible )
      series.hidden = true;

// Highlight when cursor on legend item
    hs = series.segments.template.states.create("hover");
    hs.properties.strokeWidth = 5;
  }

}


//
// -- Reducers

function createAllRedSeries() {  // Unused!
  var p = chart_data.predictions[c_ipre], hs;

  for (var i = 0; i < aux.preinfo[c_ipre].n_reds; i++) {
    var rname = aux.preinfo[c_ipre].reducers[i];
console.log('Create reducer:', rname);
    var reducer = p.reducers[rname];
    
    var series = chart.series.push(new am4charts.LineSeries());
    series.dataFields.categoryX = 'x';
    series.dataFields.valueY = rname;

    series.name = rname;
    series.strokeWidth = 2;
    series.legendSettings.valueText = "{valueY}";


    if ( reducer.meta.color !== 'auto' ) {  // User selected color?
      series.stroke = reducer.meta.color;
      series.fill = reducer.meta.color;
    } else {
      // Skip colors used for components
      series.stroke = mycolors[aux.preinfo[c_ipre].n_comps + i].hex;
      series.fill = mycolors[aux.preinfo[c_ipre].n_comps + i].hex;
    }

    if ( !reducer.meta.default_visible )  // Reducer to hide?
      series.hidden = true;

// Highlight when cursor on legend item
    hs = series.segments.template.states.create("hover");
    hs.properties.strokeWidth = 5;
  }
}


//
// -- Extract and manage the metadata info

var getauxinfo = function() {  // TODO

  c_ipre = 0;  // Reset the predition(s) index

  //aux.name = 'None';  // chart_data.meta.object.name;
  //aux.ra = 0.0;  // chart_data.meta.object.raj2000;
  //aux.dec = 0.0;  //chart_data.meta.object.dej2000;
  aux.z = '';  //chart_data.meta.object.z;
  aux.e_bv = '';  //chart_data.meta.object.e_bv;

// Multiple predictions for the same "object" are allowed (TODO)
  aux.n_p = chart_data.predictions.length;
  aux.n_d = (chart_data.data !== undefined) ? chart_data.data.length : 0;
  aux.preinfo = [];
  aux.preinfo.length = 0;
  aux.datinfo = [];
  aux.datinfo.length = 0;

  var cnames, rnames, desc, x_lab, y_lab, n_x, x_step;

  for (var i = 0; i < aux.n_p; i++) {
    cnames = Object.keys(chart_data.predictions[i].components);
    rnames = Object.keys(chart_data.predictions[i].reducers);

    n_x = chart_data.predictions[i].x.length;

    desc = 'Object/Data: <strong>';
    if ( aux.n_d > 0 && chart_data.data[i] !== undefined )
	desc += chart_data.data[i].meta.label;
    else
	desc += 'None';
    desc += '</strong> &minus; ';
//if (  aux.z !== '' ) desc += ':  &nbsp;&nbsp; z: '+ aux.z +', E(B-V): '+ aux.e_bv;

    desc += chart_data.predictions[i].meta.label +' &minus; Rebin: '+
	    chart_data.predictions[i].meta.rebin;

    x_lab = chart_data.predictions[i].meta.label_x;
    if ( x_lab !== '' ) {
	x_lab += ' ('; 
	var un = chart_data.predictions[i].meta.scale_x.toString().replace(/\+/,'');
	if ( un !== '1' )
		x_lab += un +'X ';
	x_lab += chart_data.predictions[i].meta.unit_x +')';
    } else
	x_lab = 'No X label';
    
    y_lab = chart_data.predictions[i].meta.label_y;
    if ( y_lab !== '' ) {
	y_lab += ' ('; 
	var un = chart_data.predictions[i].meta.scale_y.toString().replace(/\+/,'');
	if ( un !== '1' )
		y_lab += un +'X ';
	y_lab += chart_data.predictions[i].meta.unit_y +')';
    } else
	y_lab = 'No Y label';
    
    x_step = Math.abs(chart_data.predictions[i].x[1] - chart_data.predictions[i].x[0]);

    aux.preinfo.push({
	title: desc,
	x_label: x_lab,
	y_label: y_lab,
	x_min: chart_data.predictions[i].x[0],
	x_max: chart_data.predictions[i].x[n_x - 1],
	x_step: x_step,
	nf_sig: nfSignificant(x_step),
	components: cnames,
	n_comps: cnames.length,
	reducers: rnames,
	n_reds: rnames.length,
	main_reducer: chart_data.predictions[i].main_reducer  // TODO
    });
  }  // end for

// The prediction selector
  var b, ss = document.getElementById('p_selector');
  ss.innerHTML = '';

  for (var i = 0; i < aux.n_p; i++) {
	b = document.createElement('button');
	b.setAttribute('type', 'button');
	b.setAttribute('class', 'p_btn');
	b.setAttribute('onclick', 'p_select('+ i +')');
	b.setAttribute('id', 'pred_'+ i);
	b.innerHTML = ' '+ (i+1).toString() +' ';
 	ss.appendChild(b);
  }
  
  for (var i = 0; i < aux.n_d; i++) {
	aux.datinfo.push({
	  resid_visible: chart_data.data[i].meta.resid_visible,
	  resid_color: (chart_data.data[i].meta.resid_color || rcolor.hex)}
	);  // TODO
  }

  document.getElementById('p_title').innerHTML = aux.preinfo[c_ipre].title;
}


//
// -- From custom "data/components/reducers" structures to default amchart data structure.

var mydata2chart = function(isel) {
  if ( isel === undefined )
    isel = c_ipre;

console.log('isel:', isel);
  var p = chart_data.predictions[isel],
	cnames = aux.preinfo[isel].components,
	rnames = aux.preinfo[isel].reducers,
	fscale = Math.pow(10, aux.preinfo[isel].nf_sig),
	mydata = [], vals = {};

// X values rounded to the N sig. factional digits
  for (var i = 0; i < p.x.length; i++) {
	vals = {};
	vals['x'] = Math.round(p.x[i] * fscale) / fscale;
	if ( aux.n_d > 0 ) {
	  vals['y'] = chart_data.data[isel].y[i];
	  vals['error'] = chart_data.data[isel].err[i];
	  vals['resid'] = chart_data.data[isel].residuals[i];
	}

	for (var j = 0; j < aux.preinfo[isel].n_reds; j++)  // Reducers
	  //if ( p.reducers[rnames[j]].y[i] > 0 )
	  vals[rnames[j]] = p.reducers[rnames[j]].y[i];

	for (var j = 0; j < aux.preinfo[isel].n_comps; j++) { // Components
          if ( !p.components[cnames[j]].meta.use_in_plot )
		continue;
	  //if ( p.components[cnames[j]].y[i] > 0 )
	  vals[cnames[j]] = p.components[cnames[j]].y[i];
	}

	mydata.push(vals);
  }

  return mydata;
}


//
// -- Create series for the the main reducer of a prediction.
//    If xsc_series=true, use it also for the X window scrolling. 

function creaMainReducer(isel, xsc_series) {
  if ( isel === undefined )
    isel = c_ipre;

  var rname = aux.preinfo[isel].main_reducer;
  var reducer = chart_data.predictions[isel].reducers[rname];

console.log('Create main reducer:', rname);
    
  var series = chart.series.push(new am4charts.LineSeries());
  series.dataFields.categoryX = 'x';
  series.dataFields.valueY = rname;

  series.name = rname;
  series.strokeWidth = 2;
  series.legendSettings.valueText = "{valueY}";

  if ( reducer.meta.color !== 'auto' ) {  // User selected color?
    series.stroke = reducer.meta.color;
    series.fill = reducer.meta.color;
  } else {
    series.stroke = mcolor.hex;
    series.fill = mcolor.hex;
  }

  if ( !reducer.meta.default_visible )  // Reducer to hide?
    series.hidden = true;

// Highlight when cursor on legend item
  hs = series.segments.template.states.create("hover");
  hs.properties.strokeWidth = 5;

  if ( xsc_series !== undefined && xsc_series == true )
    chart.scrollbarX.series.push(series);
}


//
// -- The data series

function creaDataSeries(isel) {
  if (isel === undefined)
    isel = c_ipre;

// No data, just the model. Create and return.
  if ( aux.n_d == 0 ) {
    creaMainReducer(isel, true);
    return;
  }

  var hs;
  sdata = [];
  sdata = chart.series.push(new am4charts.LineSeries());
  sdata.dataFields.categoryX = 'x';
  sdata.dataFields.valueY = 'y';
  sdata.name = 'data';  // chart_data.meta.data.label;
  sdata.strokeWidth = 2;
  sdata.minBulletDistance = 3;  // Error visible if points are not closer than 3 pixels
  sdata.legendSettings.valueText = '{valueY}';
  //sdata.legendSettings.valueText = '[font-size: 1rem]{valueY} \u00B1 {error}[/]';


// User selected color?
  if ( chart_data.data[isel].meta.color !== 'auto' ) {
    sdata.stroke = chart_data.data[isel].meta.color;
    sdata.fill = chart_data.data[isel].meta.color;
  } else {
    sdata.stroke = dcolor.hex;
    sdata.fill = dcolor.hex;
  }
 
// Highlight when cursor on legend item
  hs = sdata.segments.template.states.create("hover");
  hs.properties.strokeWidth = 5;

// Errors
  var errorBullet = sdata.bullets.create(am4charts.ErrorBullet);
  errorBullet.isDynamic = true;
  errorBullet.strokeWidth = 1;
  errorBullet.width = 1;


// Adapter adjusts height of a bullet
  errorBullet.adapter.add("pixelHeight", function (pixelHeight, target) {
    var dataItem = target.dataItem;

    if (dataItem) {
	var value = dataItem.valueY;
	var errorTopValue = value + dataItem.dataContext.error;
	var errorTopY = valueAxis.valueToPoint(errorTopValue).y;

	var errorBottomValue = value - dataItem.dataContext.error;
	var errorBottomY = valueAxis.valueToPoint(errorBottomValue).y;

	return Math.abs(errorTopY - errorBottomY);
    }
    return pixelHeight;
  });

  chart.scrollbarX.series.push(sdata);  // If no data use ruducer? (TODO)


// -- Main Reducer always first (and before resisuals and the components)

  creaMainReducer(isel);


// Residuals

  if ( typeof sdata.residuals !== undefined ) {  // TODO
    resid = chart.series.push(new am4charts.LineSeries());
    resid.dataFields.categoryX = 'x';
    resid.dataFields.valueY = 'resid';
    resid.name = 'residuals';  // chart_data.data.meta.resid_label;
    resid.yAxis = valueAxis2;
    resid.strokeWidth = 2;
    resid.legendSettings.valueText = "{valueY}";

// Visible?
    sdata.resid_visible = aux.datinfo[isel].resid_visible;

//if (chart_data.data[isel].meta.resid_visible) {
    if ( sdata.resid_visible ) {
	range.grid.strokeOpacity = 0.5;
	range2.axisFill.fillOpacity = 0.1;
	valueAxis.renderer.grid.template.strokeOpacity = 0;
	valueAxis2.renderer.ticks.template.strokeOpacity = 1;
    } else {
	valueAxis2.visible = false;  // TODO
	valueAxis2.cursorTooltipEnabled = false;
	resid.hidden = true;

	range.grid.strokeOpacity = 0;
	range2.axisFill.fillOpacity = 0; 
    }

  
// User selected color?
    if ( aux.datinfo[isel].resid_color !== 'auto' ) {
	resid.stroke = aux.datinfo[isel].resid_color;
	resid.fill = aux.datinfo[isel].resid_color;
    } else {
	resid.stroke = rcolor.hex;
	resid.fill = rcolor.hex;
    }
  }  // end sdata.residuals


// Highlight when cursor on legend item
  hs = resid.segments.template.states.create("hover");
  hs.properties.strokeWidth = 5;
}


//
// -- Create series for each component and reducer of a prediction

function creaCompSeries(isel) {
  if ( isel === undefined )
    isel = c_ipre;

  var	p = chart_data.predictions[isel],
	data = [], cname, rname, component, reducer, hs;

  xAxis.title.text = aux.preinfo[isel].x_label;
  valueAxis.title.text = aux.preinfo[isel].y_label;

// -- Components
  for (var i = 0; i < aux.preinfo[isel].n_comps; i++) {  // Components in a prediction
	cname = aux.preinfo[isel].components[i];
	component = p.components[cname];
    
	if ( !component.meta.use_in_plot )  // Component has data?
	  continue;

console.log('Create component:', cname);
    
	var series = chart.series.push(new am4charts.LineSeries());
	series.dataFields.categoryX = 'x';
	series.dataFields.valueY = cname;

	series.name = cname;
	series.strokeWidth = 2;
	series.legendSettings.valueText = "{valueY}";

	if ( component.meta.color !== 'auto' ) {  // User selected color?
	  series.stroke = component.meta.color;
	  series.fill = component.meta.color;
	} else {
	  series.stroke = mycolors[i % n_myc].hex;
	  series.fill = mycolors[i % n_myc].hex;
	}

	if ( !component.meta.default_visible )  // Component to hide?
	  series.hidden = true;

// Highlight when cursor on legend item
	hs = series.segments.template.states.create("hover");
	hs.properties.strokeWidth = 5;
  }  // end for i


// -- Reducers (excluding the main)

  for (var i = 0; i < aux.preinfo[isel].n_reds; i++) {  // Reducers in a prediction
    var rname = aux.preinfo[isel].reducers[i];

    if ( rname.indexOf(aux.preinfo[isel].main_reducer) == 0 )  // This is the main reducers: skip
	continue;

console.log('Create reducer:', rname);
    
    reducer = p.reducers[rname];
    var series = chart.series.push(new am4charts.LineSeries());
    series.dataFields.categoryX = 'x';
    series.dataFields.valueY = rname;

    series.name = rname;
    series.strokeWidth = 2;
    series.legendSettings.valueText = "{valueY}";

    if ( reducer.meta.color !== 'auto' ) {  // User selected color?
      series.stroke = reducer.meta.color;
      series.fill = reducer.meta.color;
    } else {
      // Skip colors used for components
      series.stroke = mycolors[(aux.preinfo[isel].n_comps + i) % n_myc].hex;
      series.fill = mycolors[(aux.preinfo[isel].n_comps + i) % n_myc].hex;
    }

    if ( !reducer.meta.default_visible )  // Reducer to hide?
      series.hidden = true;

// Highlight when cursor on legend item
    hs = series.segments.template.states.create("hover");
    hs.properties.strokeWidth = 5;
  }  // end for i

}


//
// -- Select current prediction from multi-predictions list

function p_select(isel) {
  if ( isel === undefined )
	isel = 0;

// First clear all series
  chart.series.each(function() {
	chart.series.removeIndex( 0 );
    //chart.series.removeIndex( chart.series.indexOf(s) );
  });

// Prediction selector buttons
  document.getElementById('pred_'+ c_ipre).className = 'p_btn';
  document.getElementById('pred_'+ isel).className = 'p_btn p_btn-selected';

  c_ipre = isel;  // Set index of selected prediction

  chart.data = mydata2chart(isel);
  creaDataSeries();
  creaCompSeries();

// TODO: change plot labels
  document.getElementById('p_title').innerHTML = aux.preinfo[c_ipre].title;
  updPredTab(chart_data.predictions[c_ipre]);
}


//
// -- amChart code

am4core.ready(function() {

// Theme animated
  am4core.useTheme(am4themes_animated);

// Sample series if points are closer than 3 pixels
  am4core.options.minPolylineStep = 3;

  chart = am4core.create('chartdiv', am4charts.XYChart);

  if ( chart_data !== undefined ) {
    var modal = document.getElementById('myModal');
    modal.className = 'modal modal-hide';

// At startup view first prediction by default? (TODO)
    getauxinfo();
    chart.data = mydata2chart(c_ipre); 

    document.getElementById('json_info').innerHTML = aux.n_spe +' data. Current: '+ (aux.preinfo[0].n_comps - 1) +'</strong> components fit.';
    size_info = '<strong>'+ numberWithCommas(chart.data.length) +'</strong> elements array';
      document.getElementById('spe_size').innerHTML = size_info;

// Highlight button for current prediction
    document.getElementById('pred_'+ c_ipre).className = 'p_btn p_btn-selected';

  } else {
    for (var j = 0; j < 2 * Math.PI; j += 0.1)
      chart.data.push({"lambda": parseInt(1000 + j*1500), "y": Math.sin(j)});

// Open the file load div
    openLoadDiv();
  }

// Create X axis
  xAxis = chart.xAxes.push(new am4charts.CategoryAxis());
  xAxis.title.fontSize = 18;
  xAxis.dataFields.category = 'x';

// Extend by the 2x x_step range
  xAxis.min = aux.preinfo[c_ipre].x_min; // - 2 * aux.preinfo[c_ipre].x_step;
  xAxis.max = aux.preinfo[c_ipre].x_max; //+ 2 * aux.preinfo[c_ipre].x_step;

  xAxis.renderer.minGridDistance = 120; // grid (TODO)

// Create main Y-values axis
  valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
  valueAxis.title.fontSize = 18;
  valueAxis.renderer.grid.template.stroke = am4core.color("#ddd");
  valueAxis.renderer.grid.template.strokeOpacity = 1;


// Eventually the second Y-value axis (for residuals). Note that it is only checked here!
  if ( typeof sdata.residuals !== undefined ) {  // TODO
    valueAxis2 = chart.yAxes.push(new am4charts.ValueAxis());
    valueAxis2.title.text = 'Residuals (\u03C3)';
    valueAxis2.renderer.opposite = true;
    valueAxis2.title.fontSize = 18;
    valueAxis2.renderer.grid.template.disabled = true;  // No grid

 
// Configure ticks
    valueAxis2.renderer.ticks.template.disabled = false;
    valueAxis2.renderer.ticks.template.strokeOpacity = 0;
    valueAxis2.renderer.ticks.template.stroke = am4core.color("#495C43");
    valueAxis2.renderer.ticks.template.strokeWidth = 2;
    valueAxis2.renderer.ticks.template.length = -10;  // Inward


// The +/- N sigma shaded region with the (dashed) 0 level. Visibility management is TODO.
    // 0 level dashed line
    range = valueAxis2.axisRanges.create();
    range.value = 0;
    range.grid.stroke = am4core.color("#396478");
    range.grid.strokeWidth = 2;
    range.grid.strokeDasharray = "4";

    // +/- N sigma shaded area with invisible strokes
    range2 = valueAxis2.axisRanges.create();
    range2.grid.stroke = am4core.color("#ff6478");
    range2.value = -n_sigma;
    range2.endValue = n_sigma;
    range2.grid.strokeOpacity = 0;
  }

// Scrollbar
  chart.scrollbarX = new am4charts.XYChartScrollbar();
  //chart.scrollbarX.series.push(sdata);

// Increase contrast by taking every second color
  //chart.colors.step = 2;


// Cursor
  chart.cursor = new am4charts.XYCursor();
  chart.cursor.behavior = 'zoomXY';
//chart.cursor.snapToSeries = s[0];


// Legend
  chart.legend = new am4charts.Legend();
  chart.legend.labels.template.text = "[bold]{name}[/]";
  chart.legend.useDefaultMarker = true;

  var marker = chart.legend.markers.template.children.getIndex(0);
  marker.cornerRadius(8, 8, 8, 8);
  marker.width = 16;
  marker.height = 16;
  marker.strokeWidth = 2;
  marker.strokeOpacity = 1;
  marker.stroke = am4core.color("#ccc");

// Values background
  var lt = chart.legend.valueLabels.template;
  lt.background.fill = am4core.color("#efefef");
  lt.background.fillOpacity = 1;
  lt.minWidth = lt.width * 1.2;  // 20% increase. This fixes width change at run time

  chart.legend.itemContainers.template.events.on("over", function(event) {
    var segments = event.target.dataItem.dataContext.segments;
    segments.each(function(segment) {
      segment.isHover = true;
    });
  });

  chart.legend.itemContainers.template.events.on("out", function(event) {
    var segments = event.target.dataItem.dataContext.segments;
    segments.each(function(segment) {
      segment.isHover = false;
    });
  });


// Manage the click on the legend labels, in particular "residuals"
  chart.legend.itemContainers.template.events.on("hit", function(ev) {
    var field = ev.target.dataItem.dataContext,
	name = ev.target.dataItem.name;


    if ( name == 'residuals' ) {  // TODO
	sdata.resid_visible = ! field.isHidden;
	resid.hidden = ! field.isHidden;
	if ( field.isHidden ) {
		n_sigma = document.getElementById('n_sigma').value;
		range2.value = -n_sigma;
		range2.endValue = n_sigma;
		range.grid.strokeOpacity = 0.5;
		range2.axisFill.fillOpacity = 0.1;
		valueAxis2.renderer.ticks.template.strokeOpacity = 1;
		valueAxis2.visible = true;  // TODO
		valueAxis2.cursorTooltipEnabled = true;
//valueAxis.renderer.grid.template.strokeOpacity = 0;
	} else {
		range.grid.strokeOpacity = 0;
		range2.axisFill.fillOpacity = 0;
		valueAxis2.renderer.ticks.template.strokeOpacity = 0;
		valueAxis2.visible = false;  // TODO
		valueAxis2.cursorTooltipEnabled = false;
//valueAxis.renderer.grid.template.strokeOpacity = 1;
	}
    }
  });


// Set up number format
  //chart.numberFormatter.numberFormat = "#,###.000";

// The export menu
  chart.exporting.menu = new am4core.ExportMenu();


// The series
  creaDataSeries();
  creaCompSeries();

// Pre-zoom the chart (%)
  //xAxis.start = 0;
  //xAxis.end = 0.5;
  //xAxis.keepSelection = true;


// -- On data validation reset X / Y range for lin/log scale, Also clear input fields.

  chart.events.on('datavalidated', function(e) {
	document.getElementById('y_log-cb').checked = false;
	valueAxis.logarithmic = false;
	valueAxis.precision = 0;
	set_x_range();
	set_y_range();
	xy_rangein_reset();  // Clear manual range input fields
  });

});  // end am4core.ready()


//
// -- Update residuals Nsigma shaded range

function n_sigma_upd(e) {
  if ( resid.hidden )
	return;

  n_sigma = e.value;
  range2.value = -n_sigma;
  range2.endValue = n_sigma;
}


//
// -- Initial X range set

function set_x_range() {
  xAxis.min = aux.preinfo[c_ipre].x_min;
  xAxis.max = aux.preinfo[c_ipre].x_max;
  xAxis.zoomToIndexes(0, chart_data.predictions[c_ipre].x.length - 1);
console.log('X range set to:', xAxis.min, xAxis.max);
}


//
// -- Initial Y range set

function set_y_range() {
	var ymin = chart_data.predictions[c_ipre].reducers[aux.preinfo[c_ipre].main_reducer].min;
	var ymax = chart_data.predictions[c_ipre].reducers[aux.preinfo[c_ipre].main_reducer].max;
	if ( aux.n_d > 0 && chart_data.data[c_ipre] !== undefined ) {
	  ymin = Math.min(ymin, Math.min(...(chart_data.data[c_ipre].y)));
	  ymax = Math.max(ymax, Math.max(...(chart_data.data[c_ipre].y)));
	}

console.log('Y range set to:', ymin, ymax);
	y_range.lin[0] = ymin;
	y_range.lin[1] = ymax;
	(ymin > 0) ? y_range.log[0] = ymin * 0.95 : y_range.log[0] = 1e-4;  // TODO
	y_range.log[1] = ymax;

	y_linlog_toggle();
}


//
// -- Toggle linear / logarithmic Y scale

function y_linlog_toggle() {
  y_log = document.getElementById('y_log-cb').checked;

  if ( y_log ) {  // From lin to log
	valueAxis.min = y_range.log[0];
	valueAxis.max = y_range.log[1];
	valueAxis.logarithmic = true;
	valueAxis.precision = 3;
	valueAxis.strictMinMax = true;
	valueAxis.extraMin = 0;
  } else {  // From log to lin
	valueAxis.min = y_range.lin[0];
	valueAxis.max = y_range.lin[1];
	valueAxis.logarithmic = false;
	valueAxis.precision = 0;
	valueAxis.strictMinMax = false;
	valueAxis.extraMin = 0.05;  // Increase by 5% the Ymin
  }
}

//
// -- Set X and Y plot range to fixed ranges

function xy_range_set() {
  var inputs = document.getElementById('range-selector-div').getElementsByTagName('input');

// Note: need to parse to Float and use getPositionLabel because Category axis is string type.
// It also wants "0.nnn" and not ".nnn"
  var x_size = xAxis.max - xAxis.min;
  if ( x_size <= 0 )
	 x_size = aux.preinfo[c_ipre].x_step;

  var x_min = (parseFloat(inputs.xmin.value !== '' ? inputs.xmin.value : xAxis.min) - xAxis.min) / x_size;
  var x_max = (parseFloat(inputs.xmax.value !== '' ? inputs.xmax.value : xAxis.max) - xAxis.min) / x_size;
  var y_min = inputs.ymin.value !== '' ? inputs.ymin.value : valueAxis.min;
  var y_max = inputs.ymax.value !== '' ? inputs.ymax.value : valueAxis.max;

// Some checks (range checks are done in getPositionLabel)
  if ( x_min > x_max ) {
	var tmp = x_max;
	x_max = x_min;
	x_min = tmp;
  } else if ( x_min == x_max )
	x_max = x_min + aux.preinfo[c_ipre].x_step / x_size; 

  xAxis.zoomToCategories(xAxis.getPositionLabel(x_min), xAxis.getPositionLabel(x_max));
  valueAxis.zoomToValues(y_min, y_max);
//console.log('x_min, x_max:', xAxis.getPositionLabel(x_min), xAxis.getPositionLabel(x_max));
//console.log('y_min, y_max:', y_min, y_max);
}


// -- Reset X and Y plot range to initial values

function xy_range_reset() {
//set_y_range();
//valueAxis.strictMinMax = false;
//console.log('reset X, Y range:', xAxis.min, xAxis.max, valueAxis.min, valueAxis.max);
  xAxis.zoomToCategories(xAxis.min, xAxis.max);
  valueAxis.zoomToValues(valueAxis.min, valueAxis.max);
}


// -- Clear range input fields

function xy_rangein_reset() {
  var inputs = document.getElementById('range-selector-div').getElementsByTagName('input');

  inputs.xmin.value = '';
  inputs.xmax.value = '';
  inputs.ymin.value = '';
  inputs.ymax.value = '';
}


//
// -- Show/hide the fit log tables

function fitlog_toggle() {
  var e = document.getElementById('fitlog_div');
  if ( ! isHidden(e) ) {
    e.className = 'div-hide';
    document.getElementById('fitlog_sect').className = 'toggle_table-hdr';
    document.getElementById('view_fitlog_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'div-show';
    document.getElementById('fitlog_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_fitlog_angle').className = 'fas fa-angle-up ud-angle';
  }
}


//
// -- Show/hide the components / predictions / reducers log tables

function comp_table_toggle() {
  var e = document.getElementById('comp_table-div');
  if ( ! isHidden(e) ) {
    e.className = 'out_table div-hide';
    document.getElementById('comp_table_sect').className = 'toggle_table-hdr';
    document.getElementById('view_comp_table_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'out_table div-show';
    document.getElementById('comp_table_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_comp_table_angle').className = 'fas fa-angle-up ud-angle';
  }
}

function pred_table_toggle() {
  var e = document.getElementById('pred_table-div');
  if ( ! isHidden(e) ) {
    e.className = 'out_table div-hide';
    document.getElementById('pred_table_sect').className = 'toggle_table-hdr';
    document.getElementById('view_pred_table_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'out_table div-show';
    document.getElementById('pred_table_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_pred_table_angle').className = 'fas fa-angle-up ud-angle';
  }
}

function fitres_table_toggle() {
  var e = document.getElementById('fitres_table-div');
  if ( ! isHidden(e) ) {
    e.className = 'out_table div-hide';
    document.getElementById('fitres_table_sect').className = 'toggle_table-hdr';
    document.getElementById('view_fitres_table_angle').className = 'fas fa-angle-down ud-angle';
  } else {
    e.className = 'out_table div-show';
    document.getElementById('fitres_table_sect').className = 'toggle_table-hdr div-selected';
    document.getElementById('view_fitres_table_angle').className = 'fas fa-angle-up ud-angle';
  }
}


//
// -- Download the full original JSON data

function savejsonobj(filename, obj) {
  var a = document.createElement('a');
  var file = new Blob([JSON.stringify(obj)], {type: 'text/plain'});

  a.href = URL.createObjectURL(file);
  a.setAttribute('download', filename);
  a.style.display = 'none';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}


//
// -- Display input JSON formatted fit results in table format
// -- Params:
//    obj: the json object (components or reducer - TODO)
//    type: 0=components, 1=prediction, 2=reducer, 3=fit_results
//    tab_id: the (html) id to give to the created table

var tableFromJson = function(obj, type, tab_id) {
  var col = [], tlab = document.createElement("div");

//console.log(obj);
// Components or reducers? (TODO)
  var contentdiv, tabdiv, tab, tb, hdr, tr, tabCell, comp, cname, nc, red, rname, nr, ncol, title;

  if ( type !== 2 ) {
	comp = obj.components;
	cname = Object.keys(comp);  // comp. names
	nc = cname.length;
//console.log(cname);
  } else {
	red = obj.reducers;
	rname = Object.keys(red);  // red. names
	nr = rname.length;
  }

// Define header from type
  switch (type) {
    case 0:
	title = '<i id="view_comp_table_angle" class="fas fa-angle-down ud-angle"></i>View Components'
	tlab.setAttribute('id', 'comp_table_sect');
	tlab.setAttribute('class', 'toggle_table-hdr');
	tlab.setAttribute('onclick', 'comp_table_toggle()');
	col = ['Component', 'Type', 'Param.', 'Value', 'Range'];	
	break;
    case 1:
	//title = 'Prediction'
	title = '<i id="view_pred_table_angle" class="fas fa-angle-down ud-angle"></i>View Prediction'
	tlab.setAttribute('id', 'pred_table_sect');
	tlab.setAttribute('class', 'toggle_table-hdr');
	tlab.setAttribute('onclick', 'pred_table_toggle()');
	col = ['Component', 'Counter', 'Min', 'Max', 'Mean', 'NaN/Inf'];	
	break;
    case 2:
	title = 'Reducer'
	tlab.setAttribute('class', 'header-lab');
	col = ['Component', 'Counter', 'Min', 'Max', 'Mean', 'NaN/Inf'];	
	break;
    case 3:
	//title = 'Best Fit results';
	//tlab.setAttribute('class', 'header-lab');
	title = '<i id="view_fitres_table_angle" class="fas fa-angle-down ud-angle"></i>View Best Fit results'
	tlab.setAttribute('id', 'fitres_table_sect');
	tlab.setAttribute('class', 'toggle_table-hdr');
	tlab.setAttribute('onclick', 'fitres_table_toggle()');
	col = ['Component', 'Param.', 'Value', 'Uncert.', 'Fixed', 'Patched'];	
	break;

    default:
	console.log(`Sorry, option not recognised: ${type}.`);
  }

  tlab.innerHTML = title;
  ncol = col.length;

// Create a table with its id

  tabdiv = document.createElement('div');
  tabdiv.appendChild(tlab);

  contentdiv = document.createElement('div');
  tabdiv.appendChild(contentdiv);

  if ( tab_id !== undefined )
	contentdiv.setAttribute('id', tab_id);
  if ( type == 0 || type == 1 )  // Components / prediction + reducer hidden by default
	contentdiv.setAttribute('class', 'div-hide');

  tab = document.createElement('table');
  contentdiv.appendChild(tab);

// Create table header row using the extracted headers above
  hdr = tab.createTHead();
  tr = hdr.insertRow(0);

  for (var i = 0; i < col.length; i++) {
	var th = document.createElement('th');
	th.innerHTML = col[i];
	tr.appendChild(th);
  }

// Table body 
  tb = tab.appendChild(document.createElement('tbody'));

// Add json data to the table as rows
  switch (type) {
    case 0:  // components
	for (var i = 0; i < nc; i++) {
	  var c = comp[cname[i]],  // comp. obj.
	   //p, // par. obj 
		par_tt = '',  // Parameter tooltip
		pname = Object.keys(c.params);  // par. names

//console.log('c:',c);
//console.log('pname:',pname);
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = c.type;	 // 2nd column is comp. type

	  var cell = pname[0];  // 3rd column is par. names
	  par_tt = '<strong>'+ cname[i] +'</strong><br />'+ pname[0] +' (unit: '+ chart_data.components[cname[i]].params[pname[0]].meta.unit +' note: '+ chart_data.components[cname[i]].params[pname[0]].meta.note +')';

	  if ( c.params[pname[0]].fixed == true )
		cell += ' (FIXED)';
	  for (var k = 1; k < pname.length; k++) {
	    cell += '<br />'+ pname[k];
	    if ( c.params[pname[k]].fixed == true )
		cell += ' (FIXED)';
	    par_tt += '<br />'+ pname[k] +' (unit: '+ chart_data.components[cname[i]].params[pname[k]].meta.unit +' note: '+ chart_data.components[cname[i]].params[pname[k]].meta.note +')';
	  }


// Add cell with tooltip text.
	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = '<div class="partip"><span class="partiptext">'+ par_tt +'</span>'+
			cell + '</div>';
//tabCell.title = par_tt;

	  cell = '';
	  var v = c.params[pname[0]].value;  // 4th is par. values
	  if ( typeof v == 'number')
		v = +v.toPrecision(4);

	  cell = v;
	  for (var k = 1; k < pname.length; k++) {
		v = c.params[pname[k]].value;
		if ( typeof v == 'number')
		  v = +v.toPrecision(4);
		cell += '<br />'+ v;
	  }
	  tabCell = tr.insertCell(-1);
	  tabCell.classList.add('al-right');
	  tabCell.innerHTML = cell;
//tabCell.title = par_tt;

	  if ( c.params[pname[0]].low === null && c.params[pname[0]].high === null )  // 5th is par. range
		cell = ''
	  else
		cell = pRange(c.params[pname[0]].low, c.params[pname[0]].high, 4);

	  for (var k = 1; k < pname.length; k++) {
		if ( c.params[pname[k]].low === null && c.params[pname[k]].high === null )
			v = ''
		else
			v = pRange(c.params[pname[k]].low, c.params[pname[k]].high, 4);
		cell += '<br />'+ v;
	  }
	  tabCell = tr.insertCell(-1);
	  tabCell.classList.add('al-right');
	  tabCell.innerHTML = cell;

	}  // end for i
	break;

    case 1:  // predictions
	var c, cell, pcol = ['counter', 'min', 'max', 'mean', 'error'];

	for (var i = 0; i < nc; i++) {
	  c = comp[cname[i]];  // comp. obj
//console.log('c:',c);
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )  // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
		if ( [pcol[j]] == 'error' )
			cell = '<span style="background: var(--danger); color: #fff; padding-left: 5px;">'+ cell +'</span>';
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}  // end for i
	break;

    case 2:  // reducers
	var c, cell, pcol = ['counter', 'min', 'max', 'mean', 'error'];

	for (var i = 0; i < nr; i++) {
	  c = red[rname[i]];  // comp. obj
//console.log('c:',c);
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = rname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )  // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}  // end for i
	break;

    case 3:  // best fit results
	for (var i = 0; i < nc; i++) {
	  var c = comp[cname[i]];  // comp. obj.
	  var pname = Object.keys(c);  // par. names
	  var pkname = [];  // par. key value names
	  //var p; // par. obj 

//console.log('c:',c);
//console.log('pname:',pname);

	  for (var key in c[pname[0]])  // Keys from first parameter
		pkname.push(key);
//console.log('pkname:',pkname);
 
	  var np_fit = 0;  // Fit params counter

	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // First column is comp. name

	  var cell = pname[0];  // Second column is par. name

	  for (var k = 1; k < pname.length; k++) {
	    cell += '<br />'+ pname[k];
	  }

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cell;

	  for (var j = 0; j < ncol - 2; j++) {  // Third+ columns are par. values
	    var cell = '';
	    var v = c[pname[0]][pkname[j]];
	    if ( typeof v == 'number') {
		v = +v.toPrecision(4);
		np_fit++;
		if ( pkname[j] == 'patched' && v !== +c[pname[0]]['val'].toPrecision(4) )
			v = '<span style="background: var(--danger); color: #fff;  padding-left: 5px;">'+ v +'</span>';
	    } else if ( pkname[j] == 'unc' ) {  // null
			v = '';
	    } else if ( pkname[j] == 'fixed' ) {
		if ( v )
			v = 'fixed';
		else
			v = '';
	    }
	    cell = v;
	    for (var k = 1; k < pname.length; k++) {
		v = c[pname[k]][pkname[j]];
		if ( typeof v == 'number') {
		  v = +v.toPrecision(4);
		  np_fit++;
		  if ( pkname[j] == 'patched' && v !== +c[pname[k]]['val'].toPrecision(4) )
			v = '<span style="background: var(--danger); color: #fff;  padding-left: 5px;">'+ v +'</span>';
		} else if ( pkname[j] == 'unc' ) {  // null
			v = '';
		} else if ( pkname[j] == 'fixed' ) {
		  if ( v )
			v = 'fixed';
		  else
			v = '';
		}
		cell += '<br />'+ v;
	    }
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }
	}

	// The summary table
	var summdiv = document.createElement('div');
	summdiv.setAttribute('class', 'summ-div');

	var div = document.createElement('div');
	div.setAttribute('class', 'summ-div-col');
	div.innerHTML = '<ul><li><div class="fres-fixw">#Data</div>'+ ':<div class="fres-int">'+ obj.ndata +'</div></li>'+
 	'<li><div class="fres-fixw">#Param</div>'+':<div class="fres-int">'+ np_fit +'</div></li>'+
	'<li><div class="fres-fixw">DOF</div>'+':<div class="fres-int">'+ obj.dof +'</div></li>'+
	'<li><div class="fres-fixw">#Param</div>'+':<div class="fres-int" style="color: '+ (obj.status == 'OK' ? 'var(--success);"' : 'var(--danger);') +'">'+ obj.status +'</div></li></ul>';

	summdiv.appendChild(div);

	div = document.createElement('div');
	div.setAttribute('class', 'summ-div-col');
	div.innerHTML = '<ul><li><div class="fres-fixw">Cost</div>'+ ':<div class="fres-float">'+ obj.cost.toPrecision(4) +'</div></li>'+
	'<li><div class="fres-fixw" style="line-height: 1.3rem;">&chi;<sup>2</sup><sub>red</sub></div>'+':<div class="fres-float">'+ (obj.cost / obj.dof).toPrecision(4) +'</div></li>'+
	'<li><div class="fres-fixw">Prob.</div>'+':<div class="fres-float">'+ Math.pow(10, obj.log10testprob).toPrecision(4) +'</div></li>'+
	'<li><div class="fres-fixw">Elapsed</div>'+':<div class="fres-float">'+ obj.elapsed.toPrecision(4) +'</div> s</li></ul>';

	summdiv.appendChild(div);

	tabdiv.appendChild(summdiv);

	break;

    default:
	console.log(`Sorry, option not recognised: ${type}.`);
  }

  return tabdiv;
}


//
// -- Update the prediction+reducer table with current data (TODO)

function updPredTab(obj) {
  var tab, tb, tr, tabCell, comp, cname, nc, red, rname, nr;
	comp = obj.components;
	cname = Object.keys(comp);  // comp. names
	nc = cname.length;
	red = obj.reducers;
	rname = Object.keys(red);  // red. names
	nr = rname.length;

	tab = document.getElementById('pred_table-div');  // predictions
	tb = tab.getElementsByTagName("tbody")[0];
	tb.innerHTML = '';

	var c, cell, pcol = ['counter', 'min', 'max', 'mean', 'error'];

	for (var i = 0; i < nc; i++) {
	  c = comp[cname[i]];  // comp. obj.
//console.log('c:',c);
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = cname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )   // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}

	tab = document.getElementById('red_table-div');  // reducers
	tb = tab.getElementsByTagName("tbody")[0];
	tb.innerHTML = '';

	for (var i = 0; i < nr; i++) {
	  c = red[rname[i]];  // comp. obj.
 
	  tr = tb.insertRow(-1);

	  tabCell = tr.insertCell(-1);
	  tabCell.innerHTML = rname[i];	 // 1st column is comp. name

	  for (var j = 0; j < pcol.length; j++) {
	    if ( typeof c[pcol[j]] == 'number' ) {
		if ( j == 0 || j == 4 )   // "error" is a counter
		  cell = parseInt(c[pcol[j]]);
		else
		  cell = +c[pcol[j]].toPrecision(4);
	    } else
		cell = '';
	    tabCell = tr.insertCell(-1);
	    tabCell.classList.add('al-right');
	    tabCell.innerHTML = cell;
	  }

	}
}

</script>


<div class="toggle_table-hdr" id="fitlog_sect" onclick="fitlog_toggle()">
  <i id="view_fitlog_angle" class="fas fa-angle-down ud-angle"></i>View GFit report
</div>

<div id="fitlog_div" class="div-hide">
  <div id="fitlog_tab">ALL THE FIT SUMMARY TABLES TO BE DISPLAYED HERE</div>
</div>

<script>
  var divShowData = document.getElementById('fitlog_tab');
  divShowData.innerHTML = "";

  tabdiv = tableFromJson(chart_data, 0, 'comp_table-div');
  divShowData.appendChild(tabdiv); // Add the components table to the container

// Current prediction/reducer tables
  tabdiv = tableFromJson(chart_data.predictions[c_ipre], 1, 'pred_table-div');
  divShowData.appendChild(tabdiv); // Add the prediction table to the container

// Add the reducer table to the prediction container
  tabdiv = tableFromJson(chart_data.predictions[c_ipre], 2, 'red_table-div');
//  divShowData.appendChild(tabdiv);
  document.getElementById('pred_table-div').appendChild(tabdiv);

  if ( chart_data.bestfit !== undefined && chart_data.bestfit !== null ) {
    tabdiv = tableFromJson(chart_data.bestfit, 3, 'fitres_table-div');
    divShowData.appendChild(tabdiv); // Add the fit_res table to the container
  }
</script>

</div>

<div class="trailer"><a style="padding-left: 180px;" href="mailto:luciano.nicastro@inaf.it">L. Nicastro</a> &amp; <a href="mailto:giorgio.calderone@inaf.it">G. Calderone</a> 2020</div>

</body>
</html>
